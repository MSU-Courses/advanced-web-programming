# Разделение кода на файлы

После того, как были изучены основные концепции PHP, можно приступить к созданию проекта. Представьте ситуацию, что у вас есть проект, который состоит из одного файла, в котором находится весь код. Это очень неудобно, поскольку приходится постоянно прокручивать файл, чтобы найти нужный фрагмент кода, а отладка и поддержка становятся сложнее. Именно поэтому важно **разделять код на несколько файлов**.

## Зачем разделять код?

1. **Удобство разработки**. Вам будет проще ориентироваться в проекте, если каждая часть кода находится в отдельном месте.
2. **Проще отлаживать**. Найти и исправить ошибку в отдельном файле гораздо легче, чем искать её в “простыне” кода.
3. **Повторное использование**. Вы можете создавать универсальные модули (_например_, для подключения к базе данных), которые легко подключаются в любом месте проекта.
4. **Читаемость**. Другим разработчикам (и даже вам самим через некоторое время) будет легче разобраться в логике работы приложения.

## Способы подключения файлов

В PHP существует **два** способа подключения файлов:

- `include` – подключает файл и продолжает выполнение скрипта. Если файл не найден, выдаётся предупреждение (warning), но выполнение кода не прерывается.
- `require` – подключает файл и прерывает выполнение скрипта в случае его отсутствия, вызывая фатальную ошибку (fatal error).

**Пример**. _Подключение файлов_

Создадим файл `functions.php`, содержащий функцию сложения двух чисел:

```php
<?php

// functions.php

/**
 * Функция сложения двух чисел
 * @param int $a
 * @param int $b
 * @return int
 */
function sum($a, $b) {
    return $a + $b;
}
```

Теперь подключим этот файл в `index.php`:

```php
<?php

require 'functions.php';

echo sum(2, 3); // 5
```

Если файл `functions.php` отсутствует, выполнение кода должно быть прервано, поэтому используется `require`. Если бы мы применили `include`, то в случае отсутствия файла код продолжил бы выполняться, но функция `sum` не была бы найдена, что привело бы к ошибке.

В PHP существуют парные функции `include_once` и `require_once`, которые подключают файл только один раз. Это полезно для предотвращения дублирования кода, особенно если один и тот же файл может быть подключён в нескольких местах. Если файл уже был подключён ранее, повторное подключение не произойдёт.

**Пример**. _Подключение файлов с использованием `require_once`_

```php
<?php

// functions.php

require_once 'functions.php';
require_once 'functions.php'; // Файл не будет подключён повторно
```

### Подключение через относительный путь

Относительные пути указываются относительно текущего файла.

**Пример**. _Подключение файла через относительный путь_

Рассмотрим структуру проекта:

```
project/
├── includes/
│   └── functions.php
└── public/
    └── index.php
```

Если файл `index.php` находится в папке `public`, а файл `functions.php` в папке `includes`, то подключение будет выглядеть следующим образом:

```php
<?php

// index.php

require '../includes/functions.php';
```

> [!NOTE]
> .. означает переход на уровень выше в файловой системе.

## Использование константы `__DIR__`

Для упрощения работы с путями в PHP существует магическая константа `__DIR__`, которая возвращает абсолютный путь к текущему файлу. Это позволяет надежно подключать файлы независимо от того, откуда запускается скрипт.

**Пример**. _Использование константы `__DIR__`_

Рассмотрим структуру проекта:

```
project/
├── includes/
│   └── functions.php
└── public/
    └── index.php
```

Подключение файла `functions.php` в `index.php` с использованием `__DIR__`:

```php
<?php

// index.php

require __DIR__ . '/../includes/functions.php';
```

**Как это работает?**

1. `__DIR__` возвращает абсолютный путь к директории текущего файла. Предположим, что `index.php` находится в папке `public`:
   1. На Windows: `C:/project/public`
   2. На Linux/macOS: `/var/www/project/public`
2. `../includes/functions.php` указывает, что нужно подняться на один уровень выше (`..`) и затем зайти в папку `includes`.
3. Итоговый путь:
   1. На Windows: `C:/project/includes/functions.php`
   2. На Linux/macOS: `/var/www/project/includes/functions.php`

Таким образом, независимо от того, где выполняется скрипт, он всегда сможет найти `functions.php`, так как использует абсолютный путь.