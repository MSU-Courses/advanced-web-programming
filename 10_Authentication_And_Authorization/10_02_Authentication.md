# Аутентификация пользователей

## Определение

**Аутентификация** – это процесс проверки подлинности пользователя, то есть установления, тот ли это человек (или программа), за кого себя выдает. В веб-разработке под аутентификацией обычно понимают вход пользователя на сайт по учетным данным (логину и паролю). Если аутентификация успешна, сайт «запоминает» пользователя как авторизованного, обычно с помощью сессии. _Аутентификация отвечает на вопрос «Кто вы?»_.

> [!NOTE]
> В примерах ниже в начале кода будут приведены вспомогательные функции для работы с пользователем. Их рекомендуется определить в отдельном файле.

## Аутентификация по логину и паролю с использованием сессий

Наиболее распространенная схема аутентификации является аутентификация по логину и паролю с использованием сессий.

**Логин** - это уникальный идентификатор пользователя, который он использует для входа в систему. Обычно это уникальное имя (`username`) пользователя или адрес электронной почты.

> [!TIP]
> Связка логин-пароль также называется **учётными данными** (от англ. **credentials**). Этот термин часто используется в документации и системах аутентификации.

### Структура таблиц базы данных

Для хранения информации о пользователях обычно используется таблица `users` со следующими полями:

- `id` — уникальный идентификатор пользователя (первичный ключ);
- `username` или `email` — логин, используемый для аутентификации;
- `password` — хеш пароля, полученный с помощью безопасной криптографической функции.

Можно добавить и дополнительные поля, в зависимости от требований приложения.

### Хранение паролей

Пароли никогда не должны сохраняться в базе данных в открытом виде. Это представляет серьёзную угрозу безопасности. В случае компрометации базы данных злоумышленник получит доступ ко всем паролям, независимо от использования HTTPS или других протоколов защиты передачи данных.

Для безопасного хранения паролей применяется **криптографический хэш** [^1] — односторонняя функция, преобразующая пароль в строку фиксированной длины. Такой хэш невозможно дешифровать обратно в оригинальный пароль, что делает его безопасным даже в случае утечки.

На сегодняшний день рекомендуются следующие алгоритмы хэширования:

- **SHA-256**. Подходит для некритичных задач, но требует дополнительной настройки.
- **bcrypt**. Медленный и устойчивый к атакам перебора. Поддерживается нативно в PHP.

Существует множество других алгоритмов, например ранее часто использовали `MD5` и `SHA-1`, но они уже устарели и не рекомендуются к использованию из-за уязвимостей.

Для надёжной работы с паролями PHP предоставляет следующие функции:

- `password_hash()` - создает хэш пароля.
- `password_verify()` - проверяет, совпадает ли введённый пароль с хэшом.

**Пример**. _Хеширование пароля_

```php
<?php

$password = $_POST['password'];

// Хеширование пароля
$hash = password_hash($password, PASSWORD_DEFAULT);
```

В данном примере:

- Константа `PASSWORD_DEFAULT` указывает на использование алгоритма по умолчанию. В настоящее время это `bcrypt`.
- Функция `password_hash()` возвращает хэш пароля, который можно сохранить в базе данных.
  - _Например_, если пользователь введет пароль `12345`, то хэш может выглядеть следующим образом: `$2y$10$e0N1Q5Z5v3x4g7h8j9k1uOa6Yz5X5Z5X5Z5X5Z5X5Z5X5Z5X5Z5`.

**Пример**. _Проверка пароля на соответствие_

```php
<?php

$inputPassword = $_POST['password'];
$storedHash = /* хэш из базы данных */;

if (password_verify($inputPassword, $storedHash)) {
   // Пароль совпадает
} else {
   // Пароль не совпадает
}
```

### Процесс регистрации

**Регистрация пользователя** — это процесс создания новой учётной записи, позволяющей получить доступ к закрытым разделам сайта или приложения.

Регистрация обычно включает следующие шаги:

1. Пользователь заполняет форму, указывая логин и пароль.
2. Сервер проверяет, существует ли уже пользователь с таким логином.
3. Если пользователь не найден, пароль хэшируется с помощью `password_hash()`, и данные сохраняются в базе.
4. После успешной регистрации пользователь может быть автоматически авторизован или перенаправлен на страницу входа.

**Пример**. _Регистрация пользователя в PHP_

```php
<?php

/*
   Вспомогательные функции
*/

/**
 * Проверяет, существует ли пользователь с заданным логином.
 *
 * @param string $username Логин пользователя
 * @return bool
 */
function userExists(string $email): bool {
    global $pdo;

    $stmt = $pdo->prepare("SELECT 1 FROM users WHERE email = ? LIMIT 1");
    $stmt->execute([$email]);

    return (bool) $stmt->fetchColumn();
}

/*
   Обработка формы регистрации
*/

session_start();

$errors = [];

$email = $_POST['email'] ?? '';
$password = $_POST['password'] ?? '';

// Простая валидация
if (empty($password) || empty($email)) {
    $errors[] = "Все поля обязательны для заполнения.";
}

// Проверка уникальности логина
if (userExists($email)) {
    $errors[] = "Пользователь с таким логином уже существует.";
}

// Регистрация, если нет ошибок
if (empty($errors)) {
    $passwordHash = password_hash($password, PASSWORD_DEFAULT);

    // Сохранение пользователя в базе данных
    $stmt = $pdo->prepare("INSERT INTO users (email, password) VALUES (?, ?, ?)");
    $stmt->execute([$email, $passwordHash]);

    // Перенаправление на страницу входа
    header('Location: /login.php');

    exit;
}
```

> [!NOTE]
> В качестве логина рекомендуется использовать **уникальный и стабильный идентификатор**, такой как `username` или `email`. Не следует использовать номер телефона или другие данные, которые могут со временем измениться, так как это усложняет идентификацию пользователя и управление учётной записью.

### Процесс аутентификации

Как было указано ранее, **аутентификация** — это процесс подтверждения личности пользователя на основе введённых им данных. Он состоит из нескольких этапов:

1. Пользователь вводит логин и пароль на странице входа.
2. Сервер получает данные и выполняет поиск пользователя в базе данных.
3. Если пользователь найден, сервер проверяет соответствие введённого пароля хешу, хранящемуся в базе.
4. При успешной проверке создаётся сессия, и пользователь считается аутентифицированным.
5. В случае ошибки сервер возвращает сообщение о неудачной попытке входа.

**Пример**. _Аутентификация пользователя в PHP на основе логина и пароля_

```php
<?php

/*
   Вспомогательные функции
*/

/**
 * Поиск пользователя по логину
 *
 * @param string $username Логин пользователя
 *
 * @return array|null
 */
function findUserByUsername(string $username, $columns = ['*']) {
    global $pdo;
    $selectFields = implode(',', $columns);
    $stmt = $pdo->prepare("SELECT {$selectFields} FROM users WHERE username = ?");
    $stmt->execute([$username]);
    return $stmt->fetch();
}

/*
   Обработка формы аутентификации
*/

session_start();

// Массив для хранения ошибок
$errors = [];

$username = $_POST['username'];
$password = $_POST['password'];

// 1. Найти пользователя по имени (например, запрос к базе данных)
$user = findUserByUsername($username);

// 2. Проверить, существует ли пользователь
// 3. Проверить хэш пароля
if (!$user || !password_verify($password, $user['password'])) {
   $errors[] = "Неверный логин или пароль";
}

if (count($errors) == 0) {
   // 4. Если нет ошибок, сохранить данные пользователя в сессии:
   $_SESSION['user'] = [
      'id' => $user['id'],
      'email' => $user['email'],
   ];

   // 5. Перенаправить пользователю на другую страницу
   header('Location: /');
   exit;
}
```

В данном примере:

- Функция `findUserByUsername()` должна вернуть `id`, `пароль` и `email` пользователя или `null`, если пользователь не найден.
- Функция `password_verify()` сравнивает введённый пароль с хешем, сохранённым в базе. Это обеспечивает безопасность и защищённость от утечек.
- После успешной аутентификации в `$_SESSION` сохраняется массив с основными данными пользователя. Это позволяет определять, авторизован ли он, на других страницах.

При обработке ошибок во время авторизации не рекомендуется сообщать пользователю, что именно было введено неверно — логин или пароль. Сообщения вроде «_Пользователь не найден_» или «_Неверный пароль_» позволяют злоумышленнику поэтапно угадывать данные и выяснять, какие логины существуют в системе. Вместо этого следует использовать общее сообщение, например: _Неверный логин или пароль_.

> [!WARNING]
> Разделение сообщений об ошибках при входе может привести к уязвимости, называемой User Enumeration (перечисление пользователей). Она позволяет злоумышленнику определить, какие логины существуют в системе, что может быть использовано для дальнейших атак.

> [!TIP]
> Для проверки авторизации на других страницах можно использовать условие `isset($_SESSION['user'])`.

После данного процесса пользователь считается **аутентифицированным**. У него активна сессия PHP (установлен `PHPSESSID` cookie, связанный с данными на сервере), в которой сохранен идентификатор пользователя.

### Эффективное управление данными пользователя через сессию — I часть

Хранение всех пользовательских данных в сессии — таких как `имя`, `email` и т. д. — не является хорошей практикой. Подобный подход может привести к несоответствию актуального состояния данных.

_Представим ситуацию_: пользователь вошёл в систему, и его данные были сохранены в сессии. Позже администратор изменяет `email` этого пользователя, однако в сессии всё ещё хранится устаревшая информация. В результате система будет использовать неверные данные вплоть до завершения сессии, что приведёт к несогласованности и потенциальным ошибкам.

Рекомендуется сохранять в сессии только уникальный идентификатор пользователя (`user_id`). Все остальные данные — `имя`, `роль`, `email` и т. д. — следует получать из базы данных по этому идентификатору при необходимости.

**Пример**. _Аутентификация без хранения лишних данных в сессии_

```php
<?php

session_start();

// Массив для ошибок
$errors = [];

$username = $_POST['username'];
$password = $_POST['password'];

// Поиск пользователя по логину
// В данном случае можно возвращать только id и хэш пароля
$user = findUserByUsername($username);

// Проверка логина и пароля
if (!$user || !password_verify($password, $user['password'])) {
   $errors[] = "Неверный логин или пароль";
}

// При успешной аутентификации сохраняется только user_id
if (empty($errors)) {
   $_SESSION['user_id'] = $userId;
   // Регенерация ID сессии для безопасности
   session_regenerate_id();
   header('Location: /');
   exit;
}
```

На других страницах, при необходимости, можно извлекать актуальные данные пользователя из базы по его идентификатору из сессии:

```php
<?php

/*
   Вспомогательные функции
*/

/**
 * Получить пользователя по ID
 */
function findUserById(int $userId, array $columns = ['*']) {
    global $pdo;
    $selectFields = implode(',', $columns);
    $stmt = $pdo->prepare("SELECT {$selectFields} FROM users WHERE id = ?");
    $stmt->execute([$userId]);
    return $stmt->fetch();
}

/**
 * Проверить, авторизован ли пользователь
 */
function isAuthenticated() {
    return isset($_SESSION['user_id']);
}

/**
 * Получить текущего пользователя
 */
function getCurrentUser() {
    return isAuthenticated() ? findUserById($_SESSION['user_id']) : null;
}


/*
   Использование данных в шаблоне

   Например, вывод имени пользователя на странице
*/

$user = getCurrentUser();

if ($user): ?>
    <div>
        <p>Добро пожаловать, <?= htmlspecialchars($user['username']) ?>!</p>
    </div>
<?php endif; ?>
```

### Эффективное управление данными пользователя через сессию — II часть

В предыдущем примере, пользователь извлекается из базы данных каждый раз, когда это было необходимо. Хотя это и обеспечивает актуальность данных, при большом количестве обращений к текущему пользователю в одном запросе, это может повлиять на производительность.

**Решение**: Кэширование пользователя в пределах одного запроса. Это позволяет избежать повторных запросов к базе данных, сохраняя данные в переменной.

> [!IMPORTANT]
> Кэширование работает только в пределах одного запроса. При следующем обращении к серверу данные будут извлечены заново для обеспечения актуальности.

**Пример**. _Кэширование пользователя в пределах одного запроса_

```php
/**
 * Получает текущего пользователя, кэшируя результат в пределах одного запроса.
 *
 * @return array|null Массив с данными пользователя или null, если пользователь не авторизован.
 */
function getCurrentUser(): ?array {
    static $cachedUser = null;

    if ($cachedUser !== null) {
        return $cachedUser;
    }

    if (!isset($_SESSION['user_id'])) {
        return null;
    }

    $cachedUser = findUserById($_SESSION['user_id']);

    return $cachedUser;
}
```

Такой способ обеспечивает баланс между производительностью и актуальностью:

- **Актуальные данные**. При первом обращении данные берутся из базы.
- **Производительность**. При повторных вызовах в рамках того же запроса возвращаются кэшированные данные.

### Механизм «Запомнить меня»

**"Запомнить меня"** (_англ. "Remember me_") — это механизм, позволяющий пользователю оставаться авторизованным даже после закрытия браузера или истечения времени сессии. Это достигается с помощью уникального токена, который сохраняется в cookie браузера и связывается с пользователем в базе данных.

> [!TIP]
> Токен — это случайная строка, которая генерируется на сервере и используется для идентификации пользователя без необходимости ввода логина и пароля при каждом запросе.

> [!NOTE]
> В некоторых современных системах функция «Запомнить меня» может быть активирована по умолчанию, даже без явного выбора пользователя.

#### Структура таблицы базы данных

Для реализации механизма «Запомнить меня» в таблицу пользователей необходимо добавить поле `remember_token`. Это поле будет использоваться для хранения уникального токена, позволяющего идентифицировать пользователя при повторном посещении сайта без активной сессии.

Итоговая структура таблицы `users`:

- `id`
- `username` или `email`
- `password`
- `remember_token` — уникальный токен, сохраняемый в базе и отправляемый в cookie браузера для автоматической авторизации.

#### Принцип работы механизма

1. При входе в систему пользователь выбирает опцию «Запомнить меня» (`checkbox`).
2. Генерируется уникальный токен, который сохраняется:
   1. В базе данных
   2. В cookie браузера, например, с именем `remember_token`.
3. При последующих визитах (если сессия недоступна) сервер проверяет наличие токена в cookie и пытается найти пользователя по этому токену.
4. Если токен валиден, выполняется автоматическая авторизация и создаётся сессия.
5. Если пользователь не выбрал опцию «Запомнить меня», токен сохраняется только в сессии и будет удалён при закрытии браузера или по истечении времени сессии.

**Пример**. _Аутентификация с использованием remember-токена_

```php
<?php


/*
   Конфигурационные параметры для токена:
   - REMEMBER_TOKEN_NAME - имя cookie, в котором будет храниться токен
   - REMEMBER_TOKEN_EXPIRATION - время жизни токена в секундах
   - REMEMBER_TOKEN_SIZE - размер токена в байтах
*/
define('REMEMBER_TOKEN_NAME', 'remember_token');
define('REMEMBER_TOKEN_EXPIRATION', 60 * 60 * 24 * 30); // 30 дней
define('REMEMBER_TOKEN_SIZE', 32);

/*
   Вспомогательные функции
*/

/**
 * Сохранить токен в базе данных
 *
 * @param int $userId Идентификатор пользователя
 * @param string $token Токен
 *
 * @return bool
 */
function saveRememberToken (int $userId, string $token) {
    global $pdo;
    $stmt = $pdo->prepare("UPDATE users SET remember_token = ? WHERE id = ?");
    return $stmt->execute([$token, $userId]);
}

/**
 * Генерация уникального токена
 *
 * @return string
 */
function generateRememberToken() {
    return bin2hex(random_bytes(REMEMBER_TOKEN_SIZE / 2));
}

/*
   Пример аутентификации пользователя с использованием токена
*/

session_start();

$username = $_POST['username'] ?? '';
$password = $_POST['password'] ?? '';
$remember = $_POST['remember'] ?? false;

$user = findUserByUsername($username);

if ($user && password_verify($password, $username['password'])) {
   // Установить сессию
   $_SESSION['user_id'] = $user['id'];

   // Если пользователь выбрал "Запомнить меня"
   if ($remember) {
      // Генерация токена
      $token = generateRememberToken();

      // Сохранение токена в базе данных
      saveRememberToken($user['id'], $token);

      // Установка cookie на 30 дней
      setcookie(REMEMBER_TOKEN_NAME, $token, time() + REMEMBER_TOKEN_EXPIRATION, '/', '', true, true);
   }

   // Регенерация ID сессии (PHPSESESSID) для безопасности
   session_regenerate_id();

   header("Location: /");
   exit;
}
```

**Пример**. _Автоматическая загрузка пользователя по токену_

```php
<?php

/*
   Вспомогательные функции
*/

/**
 * Найти пользователя по токену
 *
 * @param string $token
 *
 * @return array|null
 */
function findUserByToken(string $token, array $columns = ['*']) {
    global $pdo;
    $selectFields = implode(',', $columns);
    $stmt = $pdo->prepare("SELECT {$selectFields} FROM users WHERE remember_token = ?");
    $stmt->execute([$token]);
    return $stmt->fetch();
}

/**
 * Загрузить пользователя по токену
 *
 * @param string $token
 *
 * @return array|null
 */
function tryLoadUserFromToken(): bool {
   // Проверяем, есть ли сессия
   if (isset($_SESSION['user_id'])) {
      return false;
   }

   $token = $_COOKIE[REMEMBER_TOKEN_NAME] ?? null;

    // Проверяем, установлен ли токен в cookie
   if (!isset($token)) {
      return false;
   }

   // Если токен установлен, ищем пользователя по токену
   $user = findUserByToken($token, ["id"]);

   session_regenerate_id(true); // Обновить идентификатор сессии

   if ($user) {
      // Обновить идентификатор пользователя
      $_SESSION['user_id'] = $user['id'];
      return true;
   }

   return false;
}

/*
   В начале каждого HTTP-запроса
*/

session_start();

tryLoadUserFromToken(); // Загрузка пользователя по токену, если сессия не установлена
```

> [!TIP]
> Для повышения безопасности при каждой аутентификация по токену необходимо генерировать новый токен и заменять старый.

### Выход из системы

**Выход из системы** — это процесс завершения сессии пользователя. Он может быть выполнен пользователем вручную (_например_, нажатием кнопки «Выйти») или автоматически (_например_, по истечении времени сессии).

```php
<?php

/**
 * Завершает текущую сессию, уничтожая все данные сессии,
 * затем запускает новую сессию и регенерирует идентификатор сессии
 * для повышения безопасности.
 */
function deleteSession() {
   // Удаление всех переменных сессии
   session_unset();

   // Очистка сессии
   session_destroy();

   // Регенерация ID сессии
   session_regenerate_id(true);

   // Удаление cookie remember_token, если оно установлено
   if (isset($_COOKIE['remember_token'])) {
      setcookie('remember_token', '', -1);
   }
}


session_start();

deleteSession();

header('Location: /login.php');
exit;
```

## Аспекты безопасности при аутентификации

Для защиты от атак и повышения надёжности системы аутентификации рекомендуется соблюдать следующие практики при работе с сессиями:

1. **Регулярно обновлять идентификатор сессии**. PHP предоставляет функцию `session_regenerate_id()`, которая генерирует новый идентификатор сессии. Её рекомендуется вызывать сразу после успешной авторизации пользователя. Это предотвращает атаку фиксации сессии (session fixation) — ситуацию, при которой злоумышленник заставляет жертву использовать заранее известный идентификатор сессии. Обновляя ID после входа, сессия безопасно привязывается к авторизованному пользователю.

   ```php
   session_regenerate_id(true); // true - удаляет старую сессию
   ```

2. **Ограничивать время жизни сессии**. По умолчанию PHP хранит данные сессии на сервере ограниченное время, заданное параметром `gc_maxlifetime` (обычно около 24 минут). Однако лучше дополнительно реализовать собственный механизм завершения сессии при длительном бездействии. Для этого можно сохранить в `$_SESSION` метку времени последней активности и проверять её при каждом запросе:

   ```php
   // В начале каждого запроса
   session_start();

   define('SESSION_TIMEOUT', 1800); // 30 минут

   if (isset($_SESSION['last_activity']) && (time() - $_SESSION['last_activity']) > SESSION_TIMEOUT) {
      // Сессия устарела
      session_unset();
      session_destroy();
      session_regenerate_id(true);
      header('Location: /login.php');
      exit;
   }

   $_SESSION['last_activity'] = time(); // Обновляем время активности
   ```

## Другие методы аутентификации

Помимо классической схемы входа по логину и паролю с использованием сессий, существуют и другие методы аутентификации, которые могут быть применены в зависимости от типа приложения, требований к безопасности и пользовательского опыта.

- **OAuth/OAuth2, SSO (одиночный вход)**. Позволяют пользователям входить в систему с помощью учётных записей сторонних сервисов (например, Google, Facebook, GitHub).
- **Аутентификация по токену без сессий**. Часто используется в REST API и SPA (одностраничных приложениях). После входа сервер выдаёт закодированный токен (например, JWT), который клиент хранит в localStorage или cookie и прикрепляет к каждому запросу. Состояние на сервере при этом не хранится.
- **Двухфакторная аутентификация (2FA)**. Добавляет второй уровень защиты: после ввода пароля требуется подтвердить вход с помощью дополнительного метода (например, одноразового кода по SMS или через приложение-аутентификатор).

Несмотря на разнообразие методов, наиболее распространённым подходом для небольших веб-приложений остаётся комбинация:

- логин и пароль;
- сессия для хранения состояния авторизации,
- и, при необходимости, cookie с токеном для функции «Запомнить меня».

[^1]: _Cryptographic Hash Functions: Definition and Examples_. investopedia [online resource]. Available at: https://www.investopedia.com/news/cryptographic-hash-functions/
[^2]: _Authentication Cheat Sheet_. cheatsheetseries.owasp.org [online resource]. Available at: https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html
