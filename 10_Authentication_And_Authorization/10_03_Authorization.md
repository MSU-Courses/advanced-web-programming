# Авторизация

## Определение

После успешной аутентификации (установления личности пользователя) необходимо решать, какие действия и ресурсы ему разрешены.

**Авторизация** – это процесс проверки прав доступа: определение, может ли данный пользователь выполнить определенное действие или получить доступ к определенному ресурсу. В отличии от аутентификации, _авторизация отвечает на вопрос "Что вы имеете право делать?"_.

Обычно в веб-приложениях авторизация строится на основании **ролей пользователя** или более низкоуровневых **прав** (permissions).

## Ограничение доступа к страницам неавторизованным пользователям

В большинстве случаев, в простых веб-приложениях не требуется сложной авторизации. Достаточно ограничить доступ к некоторым страницам неавторизованным пользователям. Например, в интернет-магазине неавторизованный пользователь может просматривать товары, но не может добавлять их в корзину или оформлять заказ.

Для этого необходимо проверить, есть ли у пользователя сессия. Если сессия не найдена, то пользователь не авторизован и его необходимо перенаправить на страницу входа.

```php
session_start();

function ifAuthenticated() {
    return isset($_SESSION['user']);
}

// Проверяем, авторизован ли пользователь
if (!ifAuthenticated()) {
    // Если не авторизован, перенаправляем на страницу входа
    header($_SERVER['SERVER_PROTOCOL']." 403 Forbidden");
    exit;
}

// Если авторизован, продолжаем выполнение кода
```

## Авторизация на основе ролей

### Определение

В более сложных веб-приложениях, таких как социальные сети, административные панели или интернет-магазины, важно разграничивать права доступа к различным функциям и ресурсам. Для этого используется механизм ролей пользователей.

**Роль** — это логическая категория, определяющая набор полномочий пользователя в системе. Роли позволяют централизованно управлять доступом и упрощают реализацию системы прав.

**Пример**. _Типовые роли пользователей в веб-приложениях_

- **Гость** — неавторизованный пользователь. Имеет доступ только к общедоступным страницам.
- **Пользователь** — зарегистрированный и вошедший в систему. Может, например, писать комментарии, оформлять заказы.
- **Администратор** — полный доступ к системе и настройкам.

### Способы хранения ролей

Роли пользователей могут храниться в базе данных различными способами. Наиболее распространенные из них:

- **Одна роль на пользователя**. В простых системах роль хранится в поле `role` таблицы пользователей.
- **Несколько ролей на одного пользователя**. В более гибких системах реализуется связь "многие ко многим" через отдельную таблицу `user_roles`, что позволяет назначать несколько ролей одному пользователю (_будет рассмотрено в следующей поглаве_).

### Проверка роли пользователя в PHP

**Пример**. _Проверка роли пользователя в PHP_

```php
<?php

session_start();


/**
 * Перечисление ролей пользователей
 */
enum Role {
   case GUEST;
   case USER;
   case ADMIN;
}

/**
 * Проверяет, является ли текущий пользователь администратором
 *
 * @param string $role Роль, которую нужно проверить
 *
 * @return bool true, если пользователь имеет указанную роль, иначе false
 */
function isUser(string $role): bool {
   // Предполагается, что функция getCurrentUser() возвращает текущего пользователям
    $user = getCurrentUser();

    return isset($user['role']) && $user['role'] === $role;
}

// Использование функции
if (!isUser(Role::ADMIN)) {
    // Отправляем код ответа 403 Forbidden - доступ запрещён
    header($_SERVER['SERVER_PROTOCOL']." 403 Forbidden");
    exit;
}

// Если у пользователя есть право, продолжаем выполнение кода
```

## Авторизация на основе прав (permissions) и ролей (roles)

### Определение

**Права (permissions)** — это конкретные действия, которые могут быть разрешены или запрещены пользователю, такие как "просмотр списка пользователей", "редактирование статьи" или "удаление комментария".

Этот подход называется RBAC (Role-Based Access Control) — управление доступом на основе ролей.

Как работает RBAC:

1. Каждая роль включает в себя определённые права.
2. Пользователи получают одну или несколько ролей.
3. При выполнении действия система проверяет, обладает ли пользователь правом на это действие, основываясь на его ролях.

Разница между ролями и правами:

- **Роль**. Определяет статус пользователя в системе (например, "редактор", "администратор")
- **Право**. Определяет конкретное действие, разрешённое роли (например, "удалить комментарий")

_Например_, Роль "редактор" может включать права: `create_post`, `edit_post`, `view_post`. Роль "администратор" `create_post`, `edit_post`, `view_post`, `delete_post` и `manage_users`.

### Хранение ролей и прав в базе данных

Для гибкой реализации системы RBAC рекомендуется использовать несколько связанных таблиц:

- `users` — таблица зарегистрированных пользователей;
- `roles` — список всех ролей;
- `capabilities` — список всех возможных прав;
- `permissions` — связь между ролями и правами;
- `user_roles` — связь между пользователями и ролями.

Такой подход позволяет:

- Назначать пользователю несколько ролей;
- Назначать роли множеству пользователей;
- Добавлять новые роли и права без изменения логики приложения.

#### Пример структуры данных

Таблица `roles`:

| id  | name   |
| --- | ------ |
| 1   | user   |
| 2   | editor |
| 3   | admin  |

Таблица `capabilities`:

| id  | name         |
| --- | ------------ |
| 1   | create_post  |
| 2   | edit_post    |
| 3   | delete_post  |
| 4   | view_post    |
| 5   | manage_users |

Таблица `permissions` (связь ролей и прав):

| role_id | capability_id |
| ------- | ------------- |
| 1       | 4             |
| 2       | 1             |
| 2       | 2             |
| 2       | 4             |
| 3       | 1             |
| 3       | 2             |
| 3       | 3             |
| 3       | 4             |
| 3       | 5             |

Таблица `users` (пользователи):

| id  | username | password | email |
| --- | -------- | -------- | ----- |
| 1   | Alice    | ...      | ...   |
| 2   | Bob      | ...      | ...   |
| 3   | Charlie  | ...      | ...   |

Таблица `user_roles` (связь пользователей и ролей):

| user_id | role_id |
| ------- | ------- |
| 1       | 1       |
| 2       | 2       |
| 3       | 3       |

### Проверка прав доступа на основе ролей и разрешений

**Пример**. _SQL-запрос для проверки прав_

```sql
SELECT COUNT(*)
FROM user_roles ur
INNER JOIN permissions p ON ur.role_id = p.role_id
INNER JOIN capabilities c ON p.capability_id = c.id
WHERE ur.user_id = <user_id> AND c.name = '<capability_name>';
```

**Если результат равен 0**, то у пользователя нет нужного права. **Если результат больше 0**, действие разрешено.

#### Реализация в PHP

В PHP можно реализовать проверку прав доступа с помощью функции, которая будет выполнять SQL-запрос к базе данных и возвращать результат проверки. Часто такую функцию называют `can()`.

**Пример**. _Функция проверки прав пользователя_

```php
<?php

/**
 * Проверяет, есть ли у пользователя заданное право
 *
 * @param string $capability Имя проверяемого права (например, 'delete_post')
 * @return bool
 */
function can(string $capability): bool {
    global $pdo;

    if (!isset($_SESSION['user_id'])) {
        return false;
    }

    $userId = $_SESSION['user_id'];

    $stmt = $pdo->prepare("
        SELECT COUNT(*)
        FROM user_roles ur
        INNER JOIN permissions p ON ur.role_id = p.role_id
        INNER JOIN capabilities c ON p.capability_id = c.id
        WHERE ur.user_id = :user_id AND c.name = :capability
    ");

    $stmt->execute([
        'user_id' => $userId,
        'capability' => $capability
    ]);

    return $stmt->fetchColumn() > 0;
}

// Использование функции
if (!can('delete_post')) {
   // Отправляем код ответа 403 Forbidden - доступ запрещён
    header($_SERVER['SERVER_PROTOCOL']." 403 Forbidden");
    exit;
}

// Если у пользователя есть право, продолжаем выполнение кода
```

> [!NOTE]
> В больших приложениях для повышения производительности рекомендуется загружать права один раз при входе пользователя и сохранять их в сессии или кэше. Это позволит избежать повторных запросов к базе данных при каждой проверке.
