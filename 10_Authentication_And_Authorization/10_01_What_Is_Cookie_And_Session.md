# Куки и Сессии

## HTTP - протокол, который не хранит состояние

Протокол HTTP изначально **не сохраняет состояние**. Это означает, что каждый HTTP-запрос обрабатывается сервером независимо, без памяти о предыдущих запросах. Если пользователь последовательно открывает несколько страниц одного сайта, только средствами HTTP невозможно понять, что все запросы исходят от одного и того же пользователя. Сервер на каждый запрос видит лишь нового клиента, не зная, «кто» делает запрос – протокол _“забывает”_ состояние между обращениями. _Например_, если вы сделали два запроса, то сервер не знает, что это один и тот же пользователь. Он видит только два отдельных запроса, которые не связаны между собой.

Однако для реальных веб-приложений важно сохранять информацию о пользователе между запросами. Например, нужно понимать, что пользователь уже вошел в систему, показывать ему персонализированные данные или, хранить содержимое корзины покупок. Без дополнительного механизма сервер не сможет различить пользователей и обеспечить непрерывное взаимодействие. Необходимы способы поддержания состояния между запросами.

В веб-разработке проблему сохранения состояния решают с помощью **Cookies** (куки) и **Sessions** (сессии). В PHP эти механизмы встроены: они позволяют отслеживать информацию о пользователе в течение сеанса работы с сайтом. Далее мы подробно разберем, как работают куки и сессии, и как на их основе реализуются аутентификация (проверка личности пользователя) и последующая авторизация доступа (проверка прав).

## Cookies: хранение состояния на клиенте

**Cookie (куки)** [^6] – это небольшой фрагмент данных, который веб-сервер передает браузеру и затем браузер сохраняет у себя. При последующих запросах к этому же серверу браузер автоматически добавляет сохраненные куки в заголовок запроса, то есть передавать их серверу. Таким образом, сервер получает от клиента информацию, сохраненную ранее, и может «узнать» пользователя. С помощью cookies можно хранить любую информацию о состоянии, потому что сам по себе HTTP не умеет этого делать [^1]. Проще говоря, когда пользователь делает запрос к серверу, сервер возвращает куки и "говорит": "Сохрани это значение у себя". Браузер сохраняет куки и при следующем запросе к этому же серверу отправляет их обратно.

Cookies обычно представляют собой пары “имя=значение”, которые сервер задает в заголовке ответа Set-Cookie, а браузер возвращает в заголовке запроса Cookie. Например, сервер может отправить заголовок:

```
Set-Cookie: theme=light;
```

После этого браузер сохранит cookie с именем `theme` и значением `light`. При каждом следующем запросе к этому серверу браузер будет добавлять заголовок:

```
Cookie: theme=light;
```

Таким образом, сервер сможет идентифицировать пользователя и его предпочтения, например, в данном случае, что пользователь предпочитает светлую тему.

**Типичные применения cookies в веб-приложениях**:

- **Управление сессией**. Хранение идентификатора сеанса, данных о входе в систему, содержимого корзины покупок и т.д. (_рассмотренно в следующей подглаве_).
- **Персонализация**. Сохранение предпочтений пользователя (_например_, язык интерфейса, тема оформления)
- **Трекинг**. Отслеживание активности пользователя для статистики или показа таргетированной рекламы.

Важно понимать, что **cookies хранятся на стороне клиента** – в браузере пользователя, и браузер отправляет их на сервер по каждому запросу. Из-за этого существует ограничение на размер и количество cookies (обычно не более ~20 куки на домен, каждый размером до ~4KB). Также вся информация в куки потенциально доступна пользователю и может быть изменена или перехвачена, поэтому нельзя хранить в cookies чувствительные данные (например, пароли в открытом виде). Вместо этого в куки обычно сохраняют только идентификаторы или токены, а вся важная информация хранится на сервере (в сессии или базе данных).

### Где посмотреть куки?

Для просмотра куки в браузере можно использовать инструменты разработчика. Например, в Google Chrome:

1. Откройте веб-приложение, для которого хотите посмотреть куки (_например_, `github.com`).
2. Откройте инструменты разработчика (для Windows: `F12` или `Ctrl+Shift+I`).
3. Перейдите на вкладку `Application` (или `Приложение`).
4. В левой колонке выберите `Cookies` и кликните на нужный домен (например, `github.com`).
5. В правой колонке вы увидите список всех куки, которые установлены для этого домена. Вы можете увидеть их имя, значение, дату истечения срока действия и другие параметры.
   <img src="https://img001.prntscr.com/file/img001/M5lgiLL5QKakeE2A3EgKjQ.png" alt="Куки в браузере" width="600px" />
6. Вы также можете удалить куки, кликнув правой кнопкой мыши на нужной куке и выбрав `Delete` (или `Удалить`).

### Установка и чтение Cookies в PHP

В PHP для отправки cookies используется функция setcookie(). Она задает cookie, отправляя соответствующий HTTP-заголовок браузеру.

_Синтаксис_:

```php
setcookie( string $name, string $value = "", int $expires_or_options = 0, string $path = "", string $domain = "", bool $secure = false, bool $httponly = false ): bool​
```

_Параметры_:

- `name` – имя cookie (строка).
- `value` – значение cookie (строка).
- `expire` – время истечения срока действия cookie — метка времени Unix, то есть количество секунд с начала эпохи.
  - Если 0 или не указано, cookie считается сессионным и будет храниться до закрытия браузера​.
  - Если указать временную метку в будущем (_например_, текущее время + число секунд), cookie будет храниться до этой даты.
- `path` – путь на сервере, для которого действует cookie (например, / – на всём сайте, или /catalog/ – только на этом разделе).
- `domain` – домен, для которого действует cookie (по умолчанию текущий домен).
- `secure` – флаг безопасности: если true, cookie отправляется только по HTTPS.
- `httponly` – флаг, запрещающий доступ к cookie из JavaScript (HttpOnly cookie).

_Пример_:

```php
<?php

setcookie("theme", "dark", time() + 60*60*24*30, "/", "", true, true);
```

На практике часто используют первые три параметра: имя, значение и время жизни​. Остальные могут пригодиться для ограничения области действия cookie и повышения безопасности. Например, `HttpOnly`-флаг рекомендуют устанавливать для cookies с чувствительными данными (такими как токен сессии), чтобы защитить их от кражи через JavaScript (XSS)​. А флаг `Secure` стоит использовать, если сайт работает по HTTPS, чтобы куки не отправлялись по нешифрованному соединению.

**Альтернативная сигнатура функции (появилась в PHP 7.3)**:

```php
setcookie(string $name, string $value = "", array $options = []): bool
```

_Параметры_:

- `name` – имя cookie (строка).
- `value` – значение cookie (строка).
- `options` – ассоциативный массив с дополнительными параметрами:
  - `expires` – время истечения срока действия cookie (метка времени Unix).
  - `path` – путь на сервере, для которого действует cookie.
  - `domain` – домен, для которого действует cookie.
  - `secure` – флаг безопасности: если true, cookie отправляется только по HTTPS.
  - `httponly` – флаг, запрещающий доступ к cookie из JavaScript (HttpOnly cookie).
  - `samesite` – ограничивает отправку cookie в запросах с других сайтов (можно указать 'Lax', 'Strict' или 'None').

_Пример_:

```php
<?php

setcookie("theme", "dark", [
    'expires' => time() + 60*60*24*30,
    'path' => '/',
    'domain' => '',
    'secure' => true,
    'httponly' => true,
    'samesite' => 'Lax'
]);
```

**Пример**. _Установка cookie и чтение его значения_

```php
<?php

// Установить cookie "theme" со значением "dark" на 30 дней:
setcookie("theme", "dark", time() + 60*60*24*30);

// Проверить, установлен ли cookie и вывести его:
$theme = isset($_COOKIE['theme']) ? $_COOKIE['theme'] : 'light';

if ($theme === 'dark') {
   echo "У вас включена темная тема";
} else {
   echo "У вас включена светлая тема";
}
```

В данном примере:

- Функция `setcookie()` отправляет заголовок браузеру с инструкцией сохранить cookie. В примере создаётся cookie с именем `theme`, значением `"dark"` и сроком действия 30 дней.
- На следующих запросах браузер автоматически отправляет сохранённые cookie обратно на сервер. В PHP они доступны через суперглобальный массив `$_COOKIE`.
- Если cookie не установлен, используется значение `'light'` — светлая тема.

> [!NOTE]
> Обратите внимание: вызывать `setcookie()` нужно до вывода любой информации в браузер (до любого `echo` или HTML-разметки). Это связано с тем, что cookies передаются заголовками HTTP, которые должны отправляться до тела ответа. Если попытаться установить cookie после вывода контента, PHP выдаст предупреждение, и cookie не будет установлен.

## Сессии: хранение состояния на сервере

Использование cookies – не единственный способ поддерживать состояние. Существует другой механизм – **сессии** [^5].

**Сессия (session)** – это механизм, позволяющий серверу сохранять данные о пользователе между запросами на своей стороне. При сессии у пользователя в браузере тоже хранится идентификатор (обычно в cookie), но все связанные данные хранятся на сервере (в _памяти_ или _файлах_). Таким образом, сессии позволяют отличать одного клиента от другого и привязывать к каждому клиенту произвольные данные, не раскрывая их браузеру. [^2].

### Как работает сессия в PHP

В PHP механизм сессий реализован следующим образом:

1. Когда мы запускаем новую сессию, PHP генерирует уникальный идентификатор сессии (например, строка вроде `1a2b3cde...`).
   1. Для получения текущего идентификатора сессии используется функция `session_id()`.
2. Этот идентификатор, как правило, передается браузеру в cookie с именем по умолчанию `PHPSESSID​`.
3. Браузер будет возвращать cookie `PHPSESSID` со значением идентификатора при каждом запросе.
4. На стороне сервера PHP создает специальный файл (или запись в хранилище), имя которого соответствует этому идентификатору сессии.
5. Все данные, которые мы сохраняем в суперглобальном массиве `$_SESSION`, записываются в этот файл на сервере.

Если cookies у пользователя отключены, PHP может автоматически добавлять идентификатор сессии в URL-адреса страниц (`?PHPSESSID=...`), чтобы передавать его через get-параметры. Однако такой способ сейчас встречается редко, и, как правило, сессии полагаются на cookie.

### Запуск и работа сессий в PHP

Чтобы воспользоваться сессией, нужно:

1. В начале каждой страницы (скрипта), где планируется доступ к данным сессии, вызывать функцию `session_start()`.
   1. Эта функция либо запускает новую сессию (генерирует идентификатор и устанавливает cookie), либо возобновляет существующую (на основе идентификатора из поступившего cookie).
2. После вызова `session_start()` становится доступен суперглобальный массив `$_SESSION`, через который можно читать и записывать данные сессии.

**Пример**. _Работа с сессиями в PHP_

```php
<?php

// На каждой странице, где нужна сессия:
session_start();

// Запись значения в сессию (например, имя пользователя):
if (isset($_POST['username'])) {
    $_SESSION['username'] = $_POST['username'];
}

// Чтение значения из сессии:
if (isset($_SESSION['username'])) {
    echo "Вы вошли как ".$_SESSION['username'];
}
```

Данные, записанные в `$_SESSION`, будут доступны при последующих запросах пользователя на других страницах, где используется `session_start()`. Это работает при условии, что браузер отправляет cookie с корректным идентификатором сессии. PHP автоматически обрабатывает загрузку и сохранение данных сессии, связывая пользователя с его сессионным хранилищем.

> [!NOTE]
> Если используется единая точка входа (_например_, `index.php`), то `session_start()` нужно вызывать в самом начале этого файла, чтобы сессия была доступна на всех страницах приложения.

Важным моментом является понимание того, что переменная `$_SESSION` уникальна для каждого пользователя. Данные, сохранённые в сессии одним пользователем, недоступны другим, даже если они используют одно и то же приложение на одном сервере.

_Например_, если один пользователь сохраняет в `$_SESSION['username']` значение `Alice`, а другой — `Bob`, то каждый из них будет видеть только свои данные. Это достигается благодаря уникальному идентификатору сессии.

### Удаление сессии

Чтобы удалить переменную из сессии, можно использовать unset(`$_SESSION['имя']`).

Для полного уничтожения сессии (например, при выходе пользователя из аккаунта) вызывают функцию `session_destroy()` – она удалит данные на сервере, а cookie с идентификатором сессии обычно инвалидируется (удаляется у клиента).

### Примеры использования сессий

#### Корзина покупок

В интернет-магазинах часто возникает необходимость сохранять содержимое корзины между переходами по страницам, даже если пользователь не авторизован. Для этого идеально подходит механизм сессий: сессия привязывается к конкретному посетителю и сохраняется на протяжении всего сеанса просмотра сайта.

**Сценарий**:

1. Пользователь добавляет товары в корзину на различных страницах каталога.
2. После перехода на страницу корзины отображается список всех отобранных товаров.

**Реализация**:

Для хранения данных корзины удобно использовать сессию. При добавлении товара данные сохраняются в массив `$_SESSION['cart']`.

**Пример**:

_Добавление товара в корзину_

```php
<?php

session_start();

$productId = $_POST['product_id'];
$quantity = $_POST['quantity'] ?? 1;

// Инициализация корзины при первом добавлении
if (!isset($_SESSION['cart'])) {
   $_SESSION['cart'] = [];
}

// Добавление товара или обновление количества, если товар уже присутствует
if (isset($_SESSION['cart'][$productId])) {
   $_SESSION['cart'][$productId]['quantity'] += $quantity;
} else {
   $_SESSION['cart'][$productId] = [
      'name' => $_POST['product_name'] ?? 'Товар ' . $productId,
      'price' => $_POST['product_price'] ?? 0,
      'quantity' => $quantity
   ];
}

// Перенаправление на страницу корзины
header("Location: cart.php");
exit;
```

_Страница корзины_

```php
<?php session_start(); ?>

<h1>Корзина</h1>
<?php if (!empty($_SESSION['cart'])): ?>
    <?php foreach ($_SESSION['cart'] as $productId => $item): ?>
        <p><?= htmlspecialchars($item['name']) ?> — <?= (int)$item['quantity'] ?> шт. по <?= (float)$item['price'] ?> руб.</p>
    <?php endforeach; ?>
<?php else: ?>
    <p>Корзина пуста.</p>
<?php endif; ?>
```

В данном примере:

1. На обеих страницах вызывается `session_start()` — это обязательное условие для работы с глобальным массивом `$_SESSION`.
2. При получении данных из формы товар добавляется в корзину. Если он уже есть — увеличивается количество.
3. На странице `cart.php` перебирается массив `$_SESSION['cart']` и выводится информация о каждом товаре.

> [!TIP]
> Для повышения безопасности рекомендуется экранировать выводимые данные с помощью `htmlspecialchars`, как показано в примере выше.

Преимуществом использования сессии является то, что все данные хранятся на сервере. Пользователь не может напрямую изменить содержимое своей корзины – только через предусмотренный интерфейс (_формы добавления/удаления_). Кроме того, данные автоматически исчезнут, когда сессия завершится (_например_, пользователь закрыл браузер или прошел таймаут сессии), что освобождает ресурсы.

#### Flash-сообщения (одноразовые уведомления)

**Flash-сообщение** – это уведомление, которое отображается пользователю однократно. Обычно используется для информирования о результатах действий, таких как успешное сохранение данных, добавление товара в корзину и т. д.

Для реализации таких сообщений удобно использовать механизм сессий. Сервер записывает сообщение в сессию и выполняет перенаправление. На целевой странице сообщение выводится, а затем немедленно удаляется, чтобы не появляться при последующих обновлениях страницы.

**Пример**. _Использование flash-сообщений_

_Запись flash-сообщения в сессию и перенаправление_

```php
<?php

session_start();

// Добавление товара в корзину или другое действие
$_SESSION['flash'] = "Товар успешно добавлен в корзину.";

// Перенаправление на нужную страницу
header("Location: cart.php");
exit;
```

_Отображение flash-сообщения на странице_

```php
<?php

session_start();

if (isset($_SESSION['flash'])) {
    echo "<div class='alert'>" . htmlspecialchars($_SESSION['flash']) . "</div>";
    unset($_SESSION['flash']);  // Удаление после показа
}
```

В данном примере:

1. После выполнения действия текст уведомления сохраняется в сессии под ключом 'flash'.
2. При загрузке целевой страницы сообщение выводится и сразу же удаляется с помощью `unset()`, чтобы избежать повторного отображения при обновлении страницы.

Flash-сообщения полезны для вывода уведомлений после перенаправления, поскольку данные через GET-параметры передавать нежелательно, так как сообщение может быть перезаписано или изменено пользователем или сообщение может быть длинным и не влезть в URL.

## Безопасность при работе с куки и сессиями

При работе с сессиями и куки необходимо учитывать следующие рекомендации по обеспечению безопасности:

1. **Не храните чувствительные данные в куки**. Пароли, номера паспортов, личные сообщения и другие конфиденциальные данные не должны сохраняться в виде куки на стороне клиента [^3]. Если возникает необходимость сохранить информацию между визитами, предпочтительно использовать уникальный идентификатор (например, ID пользователя или токен доступа), по которому сервер сможет получить нужные данные. Сами данные рекомендуется хранить только на стороне сервера.
2. **Идентификатор сессии должен быть надёжно защищён**. Поскольку сессия идентифицируется по уникальному ID (например, значению куки `PHPSESSID`), важно исключить возможность его перехвата. Для этого
   1. Следует использовать HTTPS, чтобы все данные, включая куки, передавались в зашифрованном виде. Это предотвращает утечку данных при прослушивании сетевого трафика.
   2. Необходимо установить флаг `HttpOnly` для сессионной куки — это ограничит доступ к ней со стороны JavaScript в браузере и затруднит кражу сессии в случае XSS-уязвимости.
   3. Также рекомендуется установить флаг Secure, чтобы куки передавались только по защищённому соединению (HTTPS).
   4. В PHP указанные параметры можно задать:
      - через функцию `session_set_cookie_params()`, которая позволяет установить параметры куки сессии, такие как путь, домен, флаги Secure и HttpOnly.
      - или в конфигурационном файле `php.ini` (например, `session.cookie_secure = On` и `session.cookie_httponly = On`).

## Что хранить в Cookies, сессиях и базе данных?

Мы рассмотрели два механизма хранения данных состояния: _куки_ и _сессии_.

Возникает вопрос – какие данные где лучше хранить? Также в веб-приложениях есть и третий важный компонент хранения – база данных. Каждый из этих вариантов имеет свои особенности:

### Сводная таблица

| Критерий      | Cookies                                                                                                                                                               | Сессии                                                                                                                                                                                                                                                       | База данных                                                                                                                                                                                                 |
| ------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Объем         | Очень ограничен (несколько килобайт). Предназначены для хранения небольших фрагментов данных.                                                                         | Может хранить больше данных, ограниченных памятью сервера и разумностью (но не бесконечно много – огромные данные лучше в БД).                                                                                                                               | Практически неограничен для приложений (ограничивается лишь хранилищем). Можно хранить большие и структурированные данные.                                                                                  |
| Длительность  | Могут быть _сессионными_ (удаляются при закрытии браузера) или _персистентными_ (хранятся до заданной даты истечения).                                                | Живут пока активна сессия – обычно до закрытия браузера или таймаута (в PHP по умолчанию ~24 минуты без активности, настраивается). Можно продлевать, пока пользователь пользуется сайтом.                                                                   | Постоянное хранение до явного удаления. Данные в БД переживают закрытие браузера, перезагрузку сервера и т.д.                                                                                               |
| Доступность   | Отправляются на сервер автоматически при каждом запросе к соответствующему домену/пути. Также доступны JavaScript (если не указан HttpOnly флаг).                     | Данные сессии не отправляются клиенту, клиент получает только идентификатор. Поэтому они невидимы и недоступны пользователю напрямую, не могут быть изменены со стороны клиента​.                                                                            | Сервер вытаскивает их из своего хранилища по `session_id`.                                                                                                                                                  |
| Безопасность  | Безопасность: Пользователь может просмотреть и изменить cookies, или злоумышленник может их украсть (например, через XSS). Не храните важные секреты в открытом виде. | Сессии безопаснее для хранения конфиденциальных данных, так как пользователь не может подделать содержимое (если session_id не скомпрометирован). Однако нужно защищать сам идентификатор (cookie с ним должен быть Secure/HttpOnly и достаточно случайным). | Наиболее безопасное место для важной информации – пароли (в виде хэшей), персональные данные, полномочия и т.д. База не зависит от клиента; если правильно настроить доступ, посторонний не получит данные. |
| Использование | Идентификатор сессии, токен “запомнить меня”, простые настройки (темная тема, язык интерфейса), данные, которым нужна доступность без входа в аккаунт.                | Данные текущего сеанса пользователя – например, его идентификатор пользователя после входа, роли, содержимое корзины, временные сообщения, любые временные объекты. То, что актуально только для данного пользователя и не нужно навсегда хранить в базе.    | Постоянная информация: учетные записи пользователей, хэши паролей, списки товаров, права пользователей, журналы действий и др.                                                                              |

### Вывод

1. **Короткоживущие и чувствительные данные сеанса** (например, отметка что пользователь залогинен) – хранить в сессии.
2. **Долгосрочные или глобальные данные** – хранить в базе данных, а в сессии или cookie держать лишь ключи/ссылки на них.
3. **Данные, нужные вне сеанса пользователя** (между запросами) – могут храниться в cookie, если они не критичны (_например_, `theme=dark`). Однако слишком много данных или приватные данные лучше хранить в БД.
4. **Не дублировать одно и то же во всех местах**. Например, не имеет смысла хранить весь профиль пользователя и в сессии, и в базе. В сессии можно сохранить идентификатор пользователя и минимум необходимой информации (например, имя для приветствия), а при необходимости подробные данные подгружать из базы.

[^1]: _HTTP-куки_. mdn [online resource]. Available at: https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies
[^2]: _PHP: использование механизмов Cookies и Session_. weblecture [online resource]. Available at: https://weblecture.ru/node/152
[^3]: _The Difference Between PHP Cookies and Sessions_. thoughtco [online resource]. Available at: https://www.thoughtco.com/the-difference-between-cookies-and-sessions-2693956
[^4]: _PHP Sessions: Explained, Practical Usage, and Best Practices_. medium [online resource]. Available at: https://medium.com/@patelharsh7458/php-sessions-explained-practical-usage-and-best-practices-b15df9cc7568
[^5]: _Sessions_. php.net [online resource]. Available at: https://www.php.net/manual/en/book.session.php
[^6]: _Cookies_. php.net [online resource]. Available at: https://www.php.net/manual/en/features.cookies.php
