# Шаблонизация и компоненты в PHP

## Введение

При разработке веб-страниц на PHP часто возникает ситуация, когда HTML-код напрямую смешивается с PHP-кодом. Это приводит к созданию трудночитаемого и плохо поддерживаемого кода, где логика приложения (PHP-код) и представление оказываются тесно переплетены. В результате страдает структурированность приложения, и даже небольшие изменения могут потребовать значительных усилий.

Решением этой проблемы является шаблонизация — разделение логики приложения (PHP-скрипты) и представления (HTML-шаблоны).

**Шаблонизация** — это процесс интеграции данных и логики PHP в структуру HTML-страницы удобным и организованным способом. Проще говоря, шаблоны позволяют описать HTML-страницу с местами для динамических данных, а PHP-код подставляет в эти места нужные значения [^1].

Кроме того, в реальных сайтах многие элементы страниц повторяются из раза в раз: шапка сайта, меню навигации, подвал (footer), карточки товаров и другие компоненты интерфейса. Чтобы не дублировать один и тот же HTML-код в каждом файле, используется компонентный подход: повторяющиеся части выносятся в отдельные _компоненты_ (частичные шаблоны), которые можно многократно подключать. _Например_, шапка сайта и подвал могут быть вынесены в отдельные файлы `header.php` и `footer.php`, которые подключаются на каждой странице. Таким образом, изменив содержимое файла `header.php`, мы автоматически обновим шапку на всех страницах сайта.

Шаблонизация и использование компонентов значительно упрощают поддержку и модификацию сайта, делая код более гибким и читаемым.

В этой главе мы последовательно познакомимся с основами шаблонизации в PHP — начиная с простейших примеров и заканчивая созданием собственного небольшого шаблонизатора. Сначала мы разберём прямое подключение файлов и вставку переменных в шаблоны, после чего перейдём к разработке функции-шаблонизатора и рассмотрим объектно-ориентированный подход к реализации шаблонов.

## Зачем нужна шаблонизация?

При разработке веб-приложений можно выделить два основных аспекта:

- **Логика** отвечает за получение и обработку данных.
- **Представление** отвечает за отображение этих данных в виде HTML-страниц.
- Новичок может начать с того, что прямо в PHP-скрипте с помощью операторов echo выводит разметку HTML, подставляя переменные.

```php
<?php

// index.php — скрипт выводит HTML с переменными
$title = "Мой сайт";
$userName = "Иван";
// Выводим HTML с использованием переменных
echo "<html><head><title>$title</title></head>";
echo "<body><h1>Добро пожаловать, $userName!</h1></body></html>";
```

На небольшом фрагменте это выглядит просто, но представьте себе страницу с десятками строк HTML-кода. Смешивание **логики** и **представления** приводит к появлению плохо структурированного кода. Любое изменение — например, добавление нового элемента меню — требует внесения правок непосредственно в PHP-код, что повышает риск ошибок. Такой код трудно переиспользовать на других страницах и сложно поддерживать, особенно по мере роста проекта.

Из этого следует один из ключевых принципов разработки — **разделение ответственностей** (Separation of Concerns, SoC) [^1]. Логика и представление должны быть чётко разделены, чтобы код оставался понятным, гибким и легко поддерживаемым.

## Типы шаблонов

Перед тем как перейти к конкретным способам шаблонизации, разберём основные типы шаблонов:

| Тип шаблона              | Назначение и содержимое                                                                                                                                                                                                                           |
| ------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Лейаут (`layout`)**    | Общий каркас HTML для страниц. Содержит повторяющиеся элементы: `<html><head>` с подключением стилей и скриптов, шапку сайта, подвал. Внутри лейаута оставляется «место» для уникального содержимого страницы, _например_, переменная `$content`. |
| **Страница (`page`)**    | Шаблон, уникальный для конкретной страницы. Включает только основной контент без общей обёртки. _Например_, на главной странице — список записей, на странице "О нас" — текст о компании. Может подключать мелкие блоки (компоненты) внутри себя. |
| **Блок (или компонент)** | Небольшой шаблон фрагмента страницы, который многократно используется в разных местах. _Например_, элемент списка (`<li>`) с содержимым записи блога, карточка товара, комментарий и т.п.                                                         |

Компоненты могут делиться на разные категории в зависимости от задачи, но в рамках курса мы будем рассматривать их как маленькие самостоятельные шаблоны, которые можно многократно использовать внутри страниц.

## Простые шаблоны с использованием require/include: разбиение страницы на части

Первый шаг к шаблонизации — разделить страницу на части и использовать встроенную возможность PHP включать один файл в другой. В PHP есть конструкции, которые были изучены ранее: `require`, `require_once`, `include`, `include_once`. Они позволяют подключать содержимое одного файла в другой.

Рассмотрим простой пример. Допустим, у нас есть несколько страниц сайта, и все они должны иметь одинаковую **шапку** (header) и **подвал** (footer). Вместо того чтобы копировать один и тот же HTML-код на каждую страницу, мы выделим общий код в компоненты: `header.php` и `footer.php`. Затем на каждой странице будем подключать эти файлы с помощью `require_once`.

Для разделения страницы можно использовать следующую структуру файлов:

- `header.php` — содержит шапку сайта (_начало HTML-документа с общими элементами_).
- `footer.php` — содержит подвал сайта (_завершение HTML-документа_).
- `index.php` — основной скрипт страницы, который подключает шапку и подвал и выводит основной контент.

**Пример**. _Разделение страницы на части с использованием `require_once`_

Файл _header.php_:

```php
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title><?php echo $pageTitle; ?></title>
</head>
<body>
    <header>
        <h1>Мой замечательный сайт</h1>
        <nav>
            <a href="/">Главная</a> |
            <a href="/about.php">О нас</a>
        </nav>
    </header>
    <main>
```

_footer.php_:

```php
    </main>
    <footer>
        &copy; <?php echo date('Y'); ?> Мой замечательный сайт
    </footer>
</body>
</html>
```

> [!NOTE]
> Обратите внимание: в `header.php` используется переменная `$pageTitle` для отображения названия страницы. Эта переменная должна быть определена до подключения файла `header.php`.

_index.php_:

```php
<?php
    $pageTitle = "Главная страница";  // Определяем заголовок страницы
    $userName = "Иван";               // Динамический контент (имя пользователя)
    require_once 'header.php';        // Подключаем шапку (начало страницы)
?>
    <!-- Основной контент страницы -->
    <h2>Добро пожаловать!</h2>
    <p>Привет, <?php echo $userName; ?>! Рады видеть вас на нашем сайте.</p>
<?php
    require_once 'footer.php';        // Подключаем подвал (конец страницы)
```

Когда PHP интерпретирует файл `index.php`, он последовательно подставляет содержимое файла `header.php` на место вызова `require_once 'header.php'`, а содержимое файла `footer.php` — на место вызова `require_once 'footer.php'`. В результате для браузера формируется цельный HTML-документ, в котором в теге `<title>` отображается "Главная страница", а в тексте приветствия — имя пользователя. [^3]​.

### Преимущества и недостатки подхода

Подключение файлов таким образом позволяет реализовать простейшую шаблонизацию в процедурном стиле. Мы разбиваем код на отдельные компоненты и подключаем их в нужных местах. Это значительно улучшает структуру проекта по сравнению с монолитным файлом, где HTML и PHP тесно переплетены. Однако такой подход всё равно предполагает использование PHP-кода внутри шаблонов (`header.php`, `footer.php` и других), что делает PHP одновременно и языком логики, и языком шаблонизации. Для небольших проектов это допустимо, но в крупных приложениях такой метод может привести к сложностям с поддержкой и масштабируемостью.

## Шаблоны с placeholders

Один из подходов к шаблонизации — использование шаблонов с метками (placeholders), которые не содержат PHP-кода, а представляют собой обычный HTML с особыми метками, обозначающими места для динамических данных. Такие шаблоны можно хранить, например, с расширением `.tpl` (от "template"), хотя это необязательно. Идея в том, чтобы дизайнер или верстальщик мог подготовить красивый HTML-файл с метками вместо динамических данных, а PHP-скрипт затем загрузил этот файл и подставил реальные значения с помощью функций замены строк или регулярных выражений.

Предположим, у нас есть шаблон приветствия на главной странице, где нужно подставить имя пользователя и название сайта. Создадим файл `welcome.tpl` с содержимым:

**Пример**. _Использование placeholders в шаблонах_

Файл `welcome.tpl`:

```html
<!-- welcome.tpl: HTML-шаблон с метками -->
<h1>Здравствуйте, {{USER_NAME}}!</h1>
<p>Добро пожаловать на сайт <strong>{{SITE_NAME}}</strong>.</p>
```

В этом шаблоне `{{USER_NAME}}` и `{{SITE_NAME}}` являются метками (_placeholders_), которые мы будем заменять на реальные данные.

> [!TIP]
> Метки можно обозначать разными способами. Мы выбрали двойные фигурные скобки для наглядности, но также можно использовать HTML-комментарии (`<!-- USER_NAME -->`) или любые другие символы, чтобы избежать конфликтов с другим кодом.

Теперь создадим PHP-скрипт, который будет загружать шаблон, находить метки и заменять их на реальные значения:

**Пример**. _Замена placeholders на значения_

Файл `index.php`:

```php
<?php
// Определяем переменные для подстановки в шаблон
$userName = "Ivan";
$siteName = "MySite";

// Загружаем шаблон из файла
$templateContent = file_get_contents("welcome.tpl");
if ($templateContent === false) {
    die("Ошибка: не удалось открыть файл шаблона.");
}

// Заменяем метки на реальные данные
$html = str_replace(
    ["{{USER_NAME}}", "{{SITE_NAME}}"],   // Массив меток
    [$userName, $siteName],               // Массив значений
    $templateContent
);

// Выводим результат
echo $html;
```

Что делает скрипт?

- **Чтение шаблона**: Функция `file_get_contents()` загружает содержимое файла `welcome.tpl` в строку `$templateContent`.
- **Замена меток**: С помощью `str_replace()` мы заменяем метки на реальные значения.
- **Вывод результата**: Полученный HTML-код с подставленными значениями выводится на экран.

Если запустить этот скрипт, на выходе получится следующий HTML-код:

```html
<h1>Здравствуйте, Иван!</h1>
<p>Добро пожаловать на сайт <strong>МойСайт</strong>.</p>
```

### Функция для рендеринга шаблонов

Чтобы избежать дублирования кода и сделать процесс подстановки более универсальным, создадим функцию:

**Пример**. _Функция для замены placeholders_

```php
<?php

function renderTemplate(string $templatePath, array $placeholders): string {
    $templateContent = file_get_contents($templatePath);
    if ($templateContent === false) {
        die("Ошибка: не удалось открыть файл шаблона.");
    }
    return str_replace(array_keys($placeholders), array_values($placeholders), $templateContent);
}

// Использование функции
$userName = "Ivan";
$siteName = "my-blog.md";

echo renderTemplate("welcome.tpl", [
    "{{USER_NAME}}" => $userName,
    "{{SITE_NAME}}" => $siteName
]);
?>
```

### Рендеринг с динамическим контентом

Иногда требуется подставить в шаблон сгенерированные данные, например, список элементов. Рассмотрим пример:

**Пример**. _Шаблон с динамическим контентом_

Файл `list.tpl`:

```html
<h2>Список продуктов</h2>
{{PRODUCT_LIST}}
```

Генерация HTML-списка и рендеринг:

```php
<?php

// Создаём массив продуктов
$products = ["Яблоко", "Банан", "Вишня"];

// Генерируем HTML-список
$productList = "<ul>";
foreach ($products as $product) {
    $productList .= "<li>$product</li>";
}
$productList .= "</ul>";

// Рендерим шаблон с подстановкой списка
echo renderTemplate("list.tpl", [
    "{{PRODUCT_LIST}}" => $productList
]);
```

### Использования layout

Подход с использованием layout-шаблонов позволяет создавать общую структуру страницы (шапку, подвал, меню и т.д.) отдельно от контента каждой страницы. Это делает код более структурированным и легко поддерживаемым: внутренние страницы содержат только контент, а общие элементы хранятся в одном месте.

**Пример**. _Layout-шаблон_

Файл `layout.tpl`. Содержит общую структуру страницы:

```html
<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>{{PAGE_TITLE}}</title>
  </head>
  <body>
    <header>
      <h1>Мой сайт</h1>
      <nav>
        <a href="/">Главная</a> |
        <a href="/about.php">О нас</a>
      </nav>
    </header>

    <main>{{PAGE_CONTENT}}</main>

    <footer>
      &copy;
      <?php echo date('Y'); ?>
      Мой сайт
    </footer>
  </body>
</html>
```

Файл `index.tpl`. Содержит контент главной страницы:

```html
<h2>Добро пожаловать!</h2>
<p>Привет, {{USER_NAME}}! Рады видеть вас на нашем сайте.</p>
```

Файл `index.php`. Рендеринг страницы с использованием layout:

```php
<?php

// Определяем переменные
$userName = "Ivan";
$pageTitle = "my-blog.md";

// Загружаем layout-шаблон
$layout = renderTemplate("layout.tpl", [
    "{{PAGE_TITLE}}" => $pageTitle,
    "{{PAGE_CONTENT}}" => renderTemplate("index.tpl", [
        "{{USER_NAME}}" => $userName
    ])
]);

echo $layout;
```

### Преимущества и недостатки подхода

_Преимущества_:

- **Простота и гибкость**. Шаблон не содержит программного кода, поэтому его легко редактировать.
- **Универсальность**. Шаблоны можно использовать и вне PHP, например, с другим языком.
- **Отделение логики от представления**. Логика работы остаётся в PHP, а шаблон отвечает только за отображение.

_Недостатки_:

- **Ограниченные возможности**. Подход подходит только для подстановки данных, но не поддерживает сложные конструкции (например, циклы или условия).
- **Проблемы с безопасностью**. При неправильной подстановке данных можно получить уязвимость к XSS.

Использование шаблонов с placeholders — удобный и простой способ отделения логики от представления. Такой подход подходит для небольших и средних проектов, где нет необходимости в сложной логике отображения.

## Функция-шаблонизатор: передача данных и сборка HTML

Работать с шаблонами вручную не всегда удобно — приходится каждый раз подключать файлы через `require`, выводить данные через `echo` и следить за структурой вывода. Чтобы сделать работу с шаблонами удобнее, введём абстракцию **_функции-шаблонизатора_**. Функция-шаблонизатор автоматически загрузит нужный шаблон, передаст в него данные и вернёт готовый HTML-код в виде строки.

### Что делает функция-шаблонизатор

Функция-шаблонизатор выполняет следующие шаги:

- **Проверка шаблона**. Убедиться, что файл с шаблоном существует.
- **Извлечение переменных**. Превратить элементы массива с данными в отдельные переменные, чтобы можно было обращаться к ним напрямую в шаблоне.
- **Буферизация вывода**. Начать сбор вывода в буфер, чтобы не отправлять его напрямую в браузер.
- **Подключение шаблона**. Загрузить файл с шаблоном и записать его содержимое в буфер.
- **Получение результата**. Извлечь всё, что накопилось в буфере, и вернуть как строку.

#### Что такое буферизация вывода

Буферизация вывода позволяет накапливать весь вывод (например, из `echo`) во временном буфере, а не отправлять его сразу пользователю. Это особенно полезно, когда нужно собрать весь HTML-код в одну строку перед выводом.

Для управления буфером в PHP используются функции:

- `ob_start()` — начать буферизацию.
- `ob_get_clean()` — получить содержимое буфера и очистить его.
- `ob_end_clean()` — просто очистить буфер без получения данных.

Проще говоря, с помощью `ob_start()` мы говорим PHP: "Начни копить вывод во временном буфере". Потом, с помощью `ob_get_clean()`, забираем всё накопленное и очищаем буфер.

**Пример**. _Буферизация вывода_

Рассмотрим пример:

```php
<?php

ob_start();
echo "Hello, ";
echo "world!";
$output = ob_get_clean();
```

В этом случае строки **"Hello, "** и **"world!"** будут сохранены в переменной `$output`, а не выведены на экран напрямую.

#### Определение функции шаблонизатора

Реализуем функцию `renderTemplate()`, которая будет принимать имя файла шаблона и массив данных для подстановки.

```php
<?php

function renderTemplate(string $templatePath, array $vars = []): string {
    // Проверяем, существует ли файл шаблона
    if (!file_exists($templatePath)) {
        return "";  // Если файла нет, возвращаем пустую строку
    }

    // Извлекаем переменные из массива $vars
    extract($vars);  // Превращаем ключи массива в переменные

    // Включаем буферизацию вывода
    ob_start();
    // Подключаем шаблон
    require_once $templatePath;
    // Получаем содержимое буфера и очищаем его
    return ob_get_clean();
}
```

- Функция `extract($vars)` — превращает элементы ассоциативного массива в переменные. Например, массив ["title" => "Hello", "name" => "John"] после вызова extract($vars) создаст переменные `$title`и`$name`.
- `ob_start()` — включает буферизацию вывода, чтобы весь вывод (например, через `echo`) временно сохранялся в буфере, а не отправлялся сразу клиенту.
- `require_once $templatePath` — подключает шаблонный файл. Вместо немедленного вывода содержимое накапливается в буфере благодаря включённой буферизации.
- `ob_get_clean()` — извлекает накопленный HTML-код из буфера и очищает его. Это позволяет получить готовую строку с HTML и отключить буферизацию.

### Сбор страницы из компонентов с помощью renderTemplate

Вернёмся к примеру сайта с повторяющимися частями: шапка (layout) и блоки контента. Представим, что мы разрабатываем простой блог. У нас есть главная страница, где отображается список последних записей (статей). Каждая запись представлена небольшим фрагментом (заголовок, краткое описание). Нам хочется использовать компоненты: отдельный шаблон для списка записей, отдельный шаблон для одиночной записи. Кроме того, шапка и подвал тоже общие.

Организуем шаблоны следующим образом:

- `layout.php` – лейаут (общий шаблон страницы) с шапкой, подвалом и местом для контента страницы.
- `posts.php` – шаблон контента главной страницы (список записей).
- `post_item.php` – шаблон блока одной записи (например, элемент списка).
- `index.php` – основной сценарий, который будет вызывать функцию-шаблонизатор и собирать итоговую страницу.

**Пример**. _Шаблоны для блога_

Файл `layout.php`:

```php
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title><?= $pageTitle; ?></title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header class="main-header">
    <h1>Мой блог</h1>
    <nav>
      <a href="/">Главная</a> |
      <a href="/about.php">О нас</a>
    </nav>
  </header>
  <div class="container">
    <!-- Уникальный контент страницы: -->
    <?= $content; ?>
  </div>
  <footer class="main-footer">
    <p>© 2025 Мой блог. Все права защищены.</p>
  </footer>
</body>
</html>
```

Обратите внимание: в `layout.php` мы ожидаем две переменные: `$pageTitle` для подстановки в `<title>` страницы и `$content` — HTML-код контента страницы, который будет вставлен в середину шаблона.

> [!NOTE]
> Мы использовали короткий синтаксис `<?= ... ?>` (это эквивалент `<?php echo ... ?>`) для вывода переменных. Этот синтаксис удобен в шаблонах для компактности.

Файл: `posts.php` – шаблон главной страницы (список всех записей):

```php
<!-- posts.php : шаблон контента главной страницы (список постов) -->
<h2>Последние записи</h2>
<div class="posts-list">
  <?php foreach ($posts as $post): ?>
    <?= renderTemplate('post_item.php', ['post' => $post]); ?>
  <?php endforeach; ?>
</div>
```

Здесь мы предполагаем, что переменная `$posts` – это массив (список) всех постов, полученных, скажем, из базы или из другого источника. Для каждой записи в цикле `foreach` мы вызываем нашу функцию `renderTemplate('post_item.php', ['post' => $post])`. То есть, для каждого элемента массива `$post` рендерится HTML фрагмент через шаблон `post_item.php`

Файл `post_item.php`:

```php
<!-- post_item.php : шаблон для одной записи в списке -->
<article class="post-item">
  <h3 class="post-title"><a href="/posts.php?id=<?= $post['id']; ?>"><?= htmlspecialchars($post['title']); ?></a></h3>
  <p class="post-excerpt"><?= htmlspecialchars($post['excerpt']); ?></p>
</article>
```

Этот шаблон предполагает переменную `$post (массив)`, содержащий данные записи: `id`, `title`, `excerpt` (например, краткий текст). Мы выводим заголовок в виде ссылки, а отрывок – просто как текст.

Теперь основной сценарий, index.php, который соберёт всю страницу:

```php
<?php

require_once 'functions.php';        // Предполагаем, что renderTemplate определена в functions.php или выше

// Пример данных (в реальности, возможно, получено из базы данных):
$posts = [
    [ "id" => 1, "title" => "Первая запись", "excerpt" => "Краткое описание первой записи..." ],
    [ "id" => 2, "title" => "Вторая запись", "excerpt" => "Краткое описание второй записи..." ],
    // ... (и так далее)
];

// 1. Рендерим контент главной страницы через шаблон posts.php
$pageContent = renderTemplate('posts.php', ['posts' => $posts]);

// 2. Рендерим полный layout, передавая туда заголовок страницы и контент
$fullPage = renderTemplate('layout.php', [
    'pageTitle' => 'Главная - Мой блог',
    'content'   => $pageContent
]);

// 3. Выводим готовую страницу
echo $fullPage;
```

Здесь происходит следующее: мы подготовили массив `$posts` с данными (двумя записями для примера). Затем вызвали `renderTemplate('posts.php', ['posts' => $posts])`. Наша функция загрузит файл `posts.php`, внутри которого переменная `$posts` станет доступна и выполнится цикл, рендерящий список записей через вложенные вызовы `renderTemplate` для каждого элемента. В итоге `renderTemplate('posts.php', ...)` вернёт HTML-код с секцией списка записей. Мы сохраняем его в `$pageContent`. Далее мы вызываем `renderTemplate('layout.php', [...])`, передавая в массиве: `'pageTitle'` и `'content'` (тот самый результат контента страницы). 

Таким образом, наш шаблонизатор позволяет легко собирать разные страницы, переиспользуя общие части. 

[^1]: _Шаблонизация в PHP_. maxsite.org [online resource]. Available at: https://maxsite.org/2024/templating-in-php
[^2]: _Separation of Concerns in Software Design_. nalexn.github.io [online resource]. Available at: https://nalexn.github.io/separation-of-concerns/
[^3]: _Шаблонизация в PHP_. htmlacademy.ru [online resource]. Available at: https://htmlacademy.ru/blog/php/templates
