# Шаблонизация в PHP

## Введение

При разработке веб-страниц на PHP часто возникает ситуация, когда HTML-код напрямую смешивается с PHP-кодом. Это приводит к созданию трудночитаемого и плохо поддерживаемого кода, где логика приложения и представление тесно переплетены. В результате нарушается структура приложения, и даже небольшие изменения могут потребовать значительных усилий.

Решением этой проблемы является шаблонизация — разделение логики приложения (PHP-скрипты) и представления (HTML-шаблоны).

**Шаблонизация** — это процесс интеграции данных и логики PHP в структуру HTML-страницы удобным и организованным способом. Проще говоря, шаблоны позволяют описать HTML-страницу с местами для динамических данных, а PHP-код подставляет в эти места нужные значения [^1].

Чтобы упростить процесс создания шаблонов, используются специальные инструменты — **шаблонизаторы**. Они помогают автоматически формировать HTML-страницы с динамическими данными, избегая прямого смешивания PHP и HTML.

Кроме того, в реальных проектах многие элементы страниц повторяются: шапка сайта, меню навигации, подвал (footer), карточки товаров и другие компоненты интерфейса. Чтобы не дублировать один и тот же HTML-код в каждом файле, используется компонентный подход: повторяющиеся части выносятся в отдельные _компоненты_ (частичные шаблоны), которые можно многократно подключать. Например, шапка сайта и подвал могут быть вынесены в отдельные файлы. Благодаря этому достаточно изменить содержимое одного файла, чтобы обновить соответствующий элемент на всех страницах сайта.

Шаблонизация и использование компонентов значительно упрощают поддержку и модификацию сайта, делая код более гибким и читаемым.

В этой главе мы последовательно познакомимся с основами шаблонизации в PHP — начиная с простейших примеров и заканчивая созданием собственного небольшого шаблонизатора. Сначала мы рассмотрим прямое подключение файлов и вставку переменных в шаблоны, затем перейдём к разработке функции-шаблонизатора и объектно-ориентированному подходу к реализации шаблонов.

## Зачем нужна шаблонизация?

При разработке веб-приложений можно выделить два основных аспекта:

- **Логика** отвечает за получение и обработку данных.
- **Представление** отвечает за отображение этих данных в виде HTML-страниц.
- Новичок может начать с того, что прямо в PHP-скрипте с помощью операторов echo выводит разметку HTML, подставляя переменные.

**Пример**. _Прямой вывод HTML-кода в PHP_

Файл _index.php_:

```php
<?php

$title = "Мой сайт";
$userName = "Иван";
// Выводим HTML с использованием переменных
echo "<html><head><title>$title</title></head>";
echo "<body><h1>Добро пожаловать, $userName!</h1></body></html>";
```

На небольшом фрагменте это выглядит просто, но представьте себе страницу с десятками строк HTML-кода. Смешивание **логики** и **представления** приводит к появлению плохо структурированного кода. Любое изменение — например, добавление нового элемента меню — требует внесения правок непосредственно в PHP-код, что повышает риск ошибок. Такой код трудно переиспользовать на других страницах и сложно поддерживать, особенно по мере роста проекта.

Из этого следует один из ключевых принципов разработки — **разделение ответственностей** (Separation of Concerns, SoC) [^2]. Логика и представление должны быть чётко разделены, чтобы код оставался понятным, гибким и легко поддерживаемым.

## Типы шаблонов

Перед тем как перейти к конкретным способам шаблонизации, выделим основные типы шаблонов:

| Тип шаблона              | Назначение и содержимое                                                                                                                                                                                                                           |
| ------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Лейаут (`layout`)**    | Общий каркас HTML для страниц. Содержит повторяющиеся элементы: `<html><head>` с подключением стилей и скриптов, шапку сайта, подвал. Внутри лейаута оставляется «место» для уникального содержимого страницы, _например_, переменная `$content`. |
| **Страница (`page`)**    | Шаблон, уникальный для конкретной страницы. Включает только основной контент без общей обёртки. _Например_, на главной странице — список записей, на странице "О нас" — текст о компании. Может подключать мелкие блоки (компоненты) внутри себя. |
| **Блок (или компонент)** | Небольшой шаблон фрагмента страницы, который многократно используется в разных местах. _Например_, элемент списка (`<li>`) с содержимым записи блога, карточка товара, комментарий и т.п.                                                         |

Компоненты могут делиться на разные категории в зависимости от задачи, но в рамках курса мы будем рассматривать их как маленькие самостоятельные шаблоны, которые можно многократно использовать внутри страниц.

## Простые шаблоны с использованием require/include: разбиение страницы на части

Первый шаг к шаблонизации — разделить страницу на части и использовать встроенную возможность PHP включать один файл в другой. В PHP есть конструкции, которые были изучены ранее: `require`, `require_once`, `include`, `include_once`. Они позволяют подключать содержимое одного файла в другой.

Рассмотрим простой пример. Допустим, у нас есть несколько страниц сайта, и все они должны иметь одинаковую **шапку** (header) и **подвал** (footer). Вместо того чтобы копировать один и тот же HTML-код на каждую страницу, мы выделим общий код в компоненты: `header.php` и `footer.php`. Затем на каждой странице будем подключать эти файлы с помощью `require_once`.

Для разделения страницы можно использовать следующую структуру файлов:

- `header.php` — содержит шапку сайта (_начало HTML-документа с общими элементами_).
- `footer.php` — содержит подвал сайта (_завершение HTML-документа_).
- `index.php` — основной скрипт страницы, который подключает шапку и подвал и выводит основной контент.

**Пример**. _Разделение страницы на части с использованием `require_once`_

Файл _header.php_:

```php
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title><?php echo $pageTitle; ?></title>
</head>
<body>
    <header>
        <h1>Мой замечательный сайт</h1>
        <nav>
            <a href="/">Главная</a> |
            <a href="/about.php">О нас</a>
        </nav>
    </header>
    <main>
```

Файл _footer.php_:

```php
    </main>
    <footer>
        &copy; <?php echo date('Y'); ?> Мой замечательный сайт
    </footer>
</body>
</html>
```

> [!NOTE]
> Обратите внимание: в `header.php` используется переменная `$pageTitle` для отображения названия страницы. Эта переменная должна быть определена до подключения файла `header.php`.

Файл _index.php_:

```php
<?php
    $pageTitle = "Главная страница";  // Определяем заголовок страницы
    $userName = "Иван";               // Динамический контент (имя пользователя)
    require_once 'header.php';        // Подключаем шапку (начало страницы)
?>
    <!-- Основной контент страницы -->
    <h2>Добро пожаловать!</h2>
    <p>Привет, <?php echo $userName; ?>! Рады видеть вас на нашем сайте.</p>
<?php
    require_once 'footer.php';        // Подключаем подвал (конец страницы)
```

Когда PHP интерпретирует файл `index.php`, он последовательно подставляет содержимое файла `header.php` на место вызова `require_once 'header.php'`, а содержимое файла `footer.php` — на место вызова `require_once 'footer.php'`. В результате для браузера формируется цельный HTML-документ, в котором в теге `<title>` отображается "Главная страница", а в тексте приветствия — имя пользователя. [^3]​.

### Преимущества и недостатки подхода

_Преимущества_:

1. **Простота и понятность**. Использование конструкций `require` и `include` не требует дополнительных библиотек и легко понимается даже начинающими разработчиками.
2. **Повторное использование кода**. Один и тот же шаблон (_например_, шапка или подвал) можно подключать на разных страницах, избегая дублирования кода.
3. **Удобная организация структуры проекта**. Вынос общих частей в отдельные файлы улучшает структуру приложения и делает его более организованным.

_Недостатки_:

1. **Ограниченная функциональность**. Данный подход подходит только для простых случаев и плохо масштабируется в крупных проектах с большим количеством шаблонов.
2. **Отсутствие логической изоляции**. Подключаемые файлы напрямую влияют на глобальное пространство имен, что может привести к конфликтам переменных.
3. **Смешивание логики и представления**. Шаблоны часто содержат PHP-код, что нарушает принцип разделения ответственности (SoC).

## Функции-компоненты для повторяющихся фрагментов HTML

Мы уже рассмотрели подход с отдельными шаблонными файлами, например, `header.php` и `footer.php`. Однако в некоторых случаях удобнее использовать функции-компоненты.

### Что такое функция-компонент

**Функция-компонент** — это обычная PHP-функция, которая возвращает готовый фрагмент HTML-кода на основе переданных данных. Она по сути выполняет роль мини-шаблона, но оформлена как функция. Это особенно полезно, когда повторяющийся HTML-фрагмент используется в разных местах приложения.

Вместо того чтобы каждый раз дублировать HTML-код или создавать отдельный файл шаблона, мы пишем функцию, которая возвращает нужный фрагмент разметки.

### Пример использования функции-компонента

Предположим, на сайте часто используется карточка поста блога с заголовком, кратким описанием и ссылкой "Читать далее". Вместо того чтобы каждый раз вручную писать HTML-код этой карточки, создадим функцию-компонент.

**Пример**. _Функция-компонент для карточки поста_

```php
function renderPostCard($post) {
    // Экранируем данные для безопасности
    $title   = htmlspecialchars($post["title"]);
    $excerpt = htmlspecialchars($post["excerpt"]);
    $id      = $post["id"];

    // Формируем HTML карточки поста и возвращаем как строку
    return "
      <div class='post-card'>
        <h3>{$title}</h3>
        <p>{$excerpt}</p>
        <a href='/post/{$id}'>Читать далее</a>
      </div>
    ";
}
```

Эта функция получает массив (или объект) `$post` с полями поста и собирает из них фрагмент разметки. При вызове `renderPostCard($post)` функция вернёт готовый HTML-код карточки поста, который можно вставить в любое место страницы.

**Пример**. _Использование функции-компонента_

```php
$posts = [
    ["id" => 1, "title" => "Новости компании", "excerpt" => "Свежие новости о нашей компании..."],
    ["id" => 2, "title" => "Советы по продукту", "excerpt" => "Как эффективно использовать наш продукт..."]
];

// Выводим карточки всех постов
foreach ($posts as $post) {
    echo renderPostCard($post);
}
```

Результат на странице:

```html
<div class="post-card">
  <h3>Новости компании</h3>
  <p>Свежие новости о нашей компании...</p>
  <a href="/post/1">Читать далее</a>
</div>
<div class="post-card">
  <h3>Советы по продукту</h3>
  <p>Как эффективно использовать наш продукт...</p>
  <a href="/post/2">Читать далее</a>
</div>
```

### Преимущества и недостатки функции-компонента

_Преимущества_:

- **Удобство использования**. Можно многократно вызывать одну и ту же функцию с разными данными.
- **Гибкость**. Легко менять структуру компонента в одном месте, не затрагивая все страницы.
- **Производительность**. Нет необходимости подключать дополнительные файлы на каждую итерацию.
- **Чистый код**. Локализация разметки и логики в одном месте улучшает читаемость.

_Недостатки_:

- **Ограниченные возможности**. Функции-компоненты не так гибки, как полноценные шаблонизаторы.
- **Отсутствие разделения логики и представления**. HTML и PHP находятся в одном файле, что может ухудшить структуру кода при сложных компонентах.
- **Трудности масштабирования**. При большом количестве компонентов код может стать трудночитаемым.

## Шаблоны с placeholders

Один из подходов к шаблонизации — использование **шаблонов с метками** (_placeholders_). Такие шаблоны представляют собой обычный HTML-код с особыми метками, обозначающими места для динамических данных. При этом в шаблонах отсутствует PHP-код, что позволяет отделить логику от представления.

Файлы с шаблонами можно сохранять с расширением **.tpl** (от _template_), однако это не является обязательным — можно использовать и привычные **.html** файлы. Основная идея заключается в том, чтобы дизайнер или верстальщик могли создать красивый HTML-документ с метками, а затем PHP-скрипт загрузил этот файл и заменил метки на реальные значения. Для этого используются функции замены строк или регулярные выражения, что позволяет гибко и удобно управлять динамическим содержимым.

Предположим, у нас есть шаблон приветствия на главной странице, где нужно подставить имя пользователя и название сайта. Создадим файл `welcome.tpl` с содержимым:

**Пример**. _Использование placeholders в шаблонах_

Файл `welcome.tpl`:

```html
<!-- welcome.tpl: HTML-шаблон с метками -->
<h1>Здравствуйте, {{USER_NAME}}!</h1>
<p>Добро пожаловать на сайт <strong>{{SITE_NAME}}</strong>.</p>
```

В этом шаблоне `{{USER_NAME}}` и `{{SITE_NAME}}` являются метками (_placeholders_), которые мы будем заменять на реальные данные.

> [!TIP]
> Метки можно обозначать разными способами. Мы выбрали двойные фигурные скобки для наглядности, но также можно использовать HTML-комментарии (`<!-- USER_NAME -->`) или любые другие символы, чтобы избежать конфликтов с другим кодом.

Теперь создадим PHP-скрипт, который будет загружать шаблон, находить метки и заменять их на реальные значения:

**Пример**. _Замена placeholders на значения_

Файл `index.php`:

```php
<?php
// Определяем переменные для подстановки в шаблон
$userName = "Ivan";
$siteName = "MySite";

// Загружаем шаблон из файла
$template = file_get_contents("welcome.tpl");
if ($templateContent === false) {
    die("Ошибка: не удалось открыть файл шаблона.");
}

// Заменяем метки на реальные данные
$html = str_replace(
    ["{{USER_NAME}}", "{{SITE_NAME}}"],   // Массив меток
    [$userName, $siteName],               // Массив значений
    $template
);

// Выводим результат
echo $html;
```

Что делает скрипт?

- **Чтение шаблона**: Функция `file_get_contents()` загружает содержимое файла `welcome.tpl` в строку `$templateContent`.
- **Замена меток**: С помощью `str_replace()` мы заменяем метки на реальные значения.
- **Вывод результата**: Полученный HTML-код с подставленными значениями выводится на экран.

На выходе получится следующий HTML-код:

```html
<h1>Здравствуйте, Иван!</h1>
<p>Добро пожаловать на сайт <strong>МойСайт</strong>.</p>
```

### Функция для рендеринга шаблонов

Чтобы избежать дублирования кода и сделать процесс подстановки более универсальным, можно создать функцию, которая будет заменять метки на значения в любом шаблоне.

**Пример**. _Функция для замены placeholders_

```php
<?php

/**
 * Заменяет метки в шаблоне на значения из массива.
 *
 * @param string $templatePath Путь к файлу шаблона
 * @param array $placeholders Ассоциативный массив меток и значений
 *
 * @return string HTML-код с подставленными значениями
 */
function renderTemplate(string $templatePath, array $placeholders): string {
    $template = file_get_contents($templatePath);

    if ($template === false) {
        die("Ошибка: не удалось открыть файл шаблона.");
        return;
    }

    foreach ($data as $key => $value) {
        // Добавляем фигурные скобки к ключу
        $placeholder = '{{' . strtoupper($key) . '}}';
        // После чего заменяем ключи на значения
        $template = str_replace($placeholder, $value, $template);
    }

    return $template;
}

// Использование функции
$userName = "Ivan";
$siteName = "my-blog.md";

echo renderTemplate("welcome.tpl", [
    "USER_NAME" => $userName,
    "SITE_NAME" => $siteName
]);
```

### Рендеринг с динамическим контентом

Иногда требуется подставить в шаблон сгенерированные данные, например, список элементов. Рассмотрим пример:

**Пример**. _Шаблон с динамическим контентом_

Файл _list.tpl_. Шаблон списка элементов:

```html
<h2>Список продуктов</h2>
{{PRODUCT_LIST}}
```

Файл _index.php_. Рендеринг шаблона с динамическим списком:

```php
<?php

// Создаём массив продуктов
$products = ["Товар 1", "Товар 2", "Товар 3"];

// Генерируем HTML-список
$productList = "<ul>";
foreach ($products as $product) {
    $productList .= "<li>$product</li>";
}
$productList .= "</ul>";

// Рендерим шаблон с подстановкой списка
echo renderTemplate("list.tpl", [
    "PRODUCT_LIST" => $productList
]);
```

### Использования layout

Шаблоны можно использовать для layout-страниц, которые содержат общую структуру страницы. Это делает код более структурированным и легко поддерживаемым: внутренние страницы содержат только контент, а общие элементы хранятся в одном месте.

**Пример**. _Layout-шаблон_

Файл `layout.tpl`. Содержит общую структуру страницы:

```html
<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>{{PAGE_TITLE}}</title>
  </head>
  <body>
    <header>
      <h1>Мой сайт</h1>
      <nav>
        <a href="/">Главная</a> |
        <a href="/about.php">О нас</a>
      </nav>
    </header>

    <main>{{PAGE_CONTENT}}</main>

    <footer>
      &copy;
      <?php echo date('Y'); ?>
      Мой сайт
    </footer>
  </body>
</html>
```

Файл `index.tpl`. Содержит контент главной страницы:

```html
<h2>Добро пожаловать!</h2>
<p>Привет, {{USER_NAME}}! Рады видеть вас на нашем сайте.</p>
```

Файл `index.php`. Рендеринг страницы с использованием layout:

```php
<?php

// Определяем переменные
$userName = "Ivan";
$pageTitle = "my-blog.md";

// Загружаем layout-шаблон
$layout = renderTemplate("layout.tpl", [
    "{{PAGE_TITLE}}" => $pageTitle,
    "{{PAGE_CONTENT}}" => renderTemplate("index.tpl", [
        "{{USER_NAME}}" => $userName
    ])
]);

echo $layout;
```

### Преимущества и недостатки подхода

_Преимущества_:

- **Простота и гибкость**. Шаблон не содержит программного кода, поэтому его легко редактировать.
- **Универсальность**. Шаблоны можно использовать и вне PHP, например, с другим языком.
- **Отделение логики от представления**. Логика работы остаётся в PHP, а шаблон отвечает только за отображение.

_Недостатки_:

- **Ограниченные возможности**. Подход подходит только для подстановки данных, но не поддерживает сложные конструкции (например, циклы или условия).
- **Проблемы с безопасностью**. При неправильной подстановке данных можно получить уязвимость к XSS.

Использование шаблонов с placeholders — удобный и простой способ отделения логики от представления. Такой подход подходит для небольших и средних проектов, где нет необходимости в сложной логике отображения.

## Шаблонизатор на основе PHP-файлов

В рассмотренном выше методе основной недостаток — отсутствие возможности использовать сложные конструкции в шаблонах, такие как циклы (`for`), условия (`if`, `else`) и другие элементы языка PHP. Это ограничивает гибкость и делает шаблоны менее выразительными.

Чтобы расширить возможности шаблонизации, можно использовать в качестве шаблона обычные PHP-файлы. Такие файлы позволяют задействовать весь потенциал языка, включая циклы, условные конструкции и любые другие возможности PHP.

Для реализации такого подхода создадим функцию, которая будет выполнять роль шаблонизатора (далее будем называть её _"функция-шаблонизатор"_ или просто "_функция"_).

Функция-шаблонизатор выполняет следующие шаги:

- **Проверка шаблона**. Убедиться, что файл с шаблоном существует.
- **Извлечение переменных**. Превратить элементы массива с данными в отдельные переменные, чтобы можно было обращаться к ним напрямую в шаблоне.
- **Буферизация вывода**. Начать сбор вывода в буфер, чтобы не отправлять его напрямую в браузер.
- **Подключение шаблона**. Загрузить файл с шаблоном и записать его содержимое в буфер.
- **Получение результата**. Извлечь всё, что накопилось в буфере, и вернуть как строку.

#### Что такое буферизация вывода

Буферизация вывода позволяет накапливать весь вывод (например, из `echo`) во временном буфере, а не отправлять его сразу пользователю. Это особенно полезно, когда нужно собрать весь HTML-код в одну строку перед выводом.

Для управления буфером в PHP используются функции:

- `ob_start()` — начать буферизацию.
- `ob_get_clean()` — получить содержимое буфера и очистить его.
- `ob_end_clean()` — просто очистить буфер без получения данных.

Проще говоря, с помощью `ob_start()` мы говорим PHP: "Начни копить вывод во временном буфере". Потом, с помощью `ob_get_clean()`, забираем всё накопленное и очищаем буфер.

**Пример**. _Буферизация вывода_

Рассмотрим пример:

```php
<?php

ob_start();
echo "Hello, ";
echo "world!";
$output = ob_get_clean();
```

В этом случае строки **"Hello, "** и **"world!"** будут сохранены в переменной `$output`, а не выведены на экран напрямую.

#### Определение функции шаблонизатора

Реализуем функцию `renderTemplate()`, которая будет принимать имя файла шаблона и массив данных для подстановки.

```php
<?php

function renderTemplate(string $templatePath, array $vars = []): string {
    // Проверяем, существует ли файл шаблона
    if (!file_exists($templatePath)) {
        return "";  // Если файла нет, возвращаем пустую строку
    }

    // Извлекаем переменные из массива $vars
    extract($vars);  // Превращаем ключи массива в переменные

    // Включаем буферизацию вывода
    ob_start();
    // Подключаем шаблон
    require_once $templatePath;
    // Получаем содержимое буфера и очищаем его
    return ob_get_clean();
}
```

- Функция `extract($vars)` — превращает элементы ассоциативного массива в переменные. Например, массив ["title" => "Hello", "name" => "John"] после вызова extract($vars) создаст переменные `$title`и`$name`.
- `ob_start()` — включает буферизацию вывода, чтобы весь вывод (например, через `echo`) временно сохранялся в буфере, а не отправлялся сразу клиенту.
- `require_once $templatePath` — подключает шаблонный файл. Вместо немедленного вывода содержимое накапливается в буфере благодаря включённой буферизации.
- `ob_get_clean()` — извлекает накопленный HTML-код из буфера и очищает его. Это позволяет получить готовую строку с HTML и отключить буферизацию.

### Сбор страницы из компонентов с помощью renderTemplate

Рассмотрим простой блог. В блоге есть: главная страница со списком последних записей (статей), где каждая запись отображается в виде карточки с заголовком и кратким описанием.

Чтобы упростить структуру кода и избежать дублирования, мы будем использовать компоненты. Создадим несколько отдельных шаблонов для разных частей страницы:

- `layout.php` — лейаут (общий каркас страницы) с шапкой, подвалом и местом для контента.
- `posts.php` — шаблон главной страницы со списком всех записей.
- `post_item.php` — шаблон карточки одной записи.
- `index.php` — основной сценарий, который собирает итоговую страницу, вызывая функцию шаблонизации.

**Пример**. _Шаблоны для блога_

Файл `layout.php`. Отвечает за общий каркас страницы: шапка, подвал и место для контента.

```php
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title><?= $pageTitle; ?></title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header class="main-header">
    <h1>Мой блог</h1>
    <nav>
      <a href="/">Главная</a> |
      <a href="/about.php">О нас</a>
    </nav>
  </header>
  <div class="container">
    <!-- Уникальный контент страницы: -->
    <?= $content; ?>
  </div>
  <footer class="main-footer">
    <p>© 2025 Мой блог. Все права защищены.</p>
  </footer>
</body>
</html>
```

> [!NOTE]
> Мы используем короткий синтаксис вывода `<?= ... ?>`, который эквивалентен `<?php echo ... ?>`. Он позволяет сделать код компактнее и удобнее для чтения.

Файл: `posts.php`. Содержит список записей. Мы предполагаем, что переменная `$posts` — это массив записей, передаваемый в шаблон.

```php
<h2>Последние записи</h2>
<div class="posts-list">
  <?php foreach ($posts as $post): ?>
    <?= renderTemplate('post_item.php', ['post' => $post]); ?>
  <?php endforeach; ?>
</div>
```

В этом шаблоне мы проходимся по массиву записей и вызываем функцию `renderTemplate() `для каждого поста. Таким образом, каждая запись рендерится с помощью отдельного шаблона `post_item.php`.

Файл `post_item.php`. Представляет собой шаблон карточки одной записи.

```php
<article class="post-item">
  <h3 class="post-title">
    <a href="/posts.php?id=<?= $post['id']; ?>"><?= htmlspecialchars($post['title']); ?></a>
  </h3>
  <p class="post-excerpt"><?= htmlspecialchars($post['excerpt']); ?></p>
</article>
```

Файл `index.php`. Собирает страницу из компонентов, передавая данные в шаблоны.

```php
<?php

require_once 'functions.php';  // Подключаем файл с функцией renderTemplate

// Пример данных (обычно они берутся из базы данных)
$posts = [
    ["id" => 1, "title" => "Первая запись", "excerpt" => "Краткое описание первой записи..."],
    ["id" => 2, "title" => "Вторая запись", "excerpt" => "Краткое описание второй записи..."]
];

// Рендерим контент главной страницы через шаблон posts.php
$content = renderTemplate('posts.php', ['posts' => $posts]);

// Рендерим полный layout, передавая заголовок и контент
$html = renderTemplate('layout.php', [
    'pageTitle' => 'Главная - Мой блог',
    'content'   => $content
]);

// Выводим готовую страницу
echo $html;
```

В данном коде:

- **Подготовка данных**. В массиве `$posts` хранятся записи блога с полями `id`, `title` и `excerpt`.
- **Рендеринг контента**. Вызывается функция `renderTemplate()` с шаблоном `posts.php` и массивом записей.
- **Рендеринг лейаута**. Готовый контент передаётся в основной шаблон layout.php, где он выводится в центре страницы.
- **Отображение**. Собранная HTML-страница выводится на экран.

Для улучшения данного кода можно создать функцию `renderPage`, которая будет рендерить страницу целиком, включая заголовок, контент и подвал. Эта функция позволит упростить процесс сборки страницы и повысит читаемость кода. Теперь достаточно одного вызова `renderPage()`, чтобы получить готовую страницу с заданным контентом.

```php
<?php

function renderPage(string $page, array $vars = [], string $layout = 'layout.php'): string {
    // Рендерим контент страницы
    $content = renderTemplate($page, $vars);

    // Рендерим layout, передавая заголовок и контент
    return renderTemplate($layout, [
        'pageTitle' => $vars['pageTitle'] ?? '';
        'content'   => $content
    ]);
}

// Использование функции
echo renderPage('posts.php', ['posts' => $posts, 'pageTitle' => 'Главная - Мой блог']);
```

### Преимущества и недостатки данного подхода

_Преимущества_:

1. **Гибкость и переиспользование кода**. Функция-шаблонизатор позволяет легко использовать одни и те же шаблоны с разными данными, что снижает дублирование кода.
2. **Удобство работы с шаблонами**. Позволяет передавать данные в шаблоны через ассоциативные массивы, что делает код более понятным и структурированным.
3. **Централизация логики рендеринга**. Вся логика обработки шаблонов сосредоточена в одной функции, что упрощает поддержку и модификацию кода.

_Недостатки_:

1. **Снижение производительности при больших объёмах данных**. Использование буферизации вывода может увеличивать потребление памяти на больших страницах или с большим количеством компонентов.
2. **Отсутствие кэширования**. При рендеринге сложных страниц каждый раз формируется новый HTML-код, что может замедлить работу при большом количестве пользователей.
3. **Смешивание логики и представления**. Несмотря на использование функции-шаблонизатора, в шаблонах всё равно могут присутствовать переменные и простые конструкции PHP. Это приводит к тому, что логика и представление не полностью разделены, что может затруднить поддержку кода.

[^1]: _Шаблонизация в PHP_. maxsite.org [online resource]. Available at: https://maxsite.org/2024/templating-in-php
[^2]: _Separation of Concerns in Software Design_. nalexn.github.io [online resource]. Available at: https://nalexn.github.io/separation-of-concerns/
[^3]: _Шаблонизация в PHP_. htmlacademy.ru [online resource]. Available at: https://htmlacademy.ru/blog/php/templates
