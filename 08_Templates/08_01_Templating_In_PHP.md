# Шаблонизация в PHP

## Введение

При разработке веб-страниц на PHP часто возникает ситуация, когда HTML-код тесно переплетается с PHP-логикой. Такое смешение приводит к созданию трудно читаемого и слабо структурированного кода. В нём сложно ориентироваться, а любые правки — даже незначительные — требуют дополнительных усилий и повышают риск ошибок.

Со временем проект разрастается, появляются новые страницы, шаблоны, блоки. В результате становится всё труднее поддерживать и развивать приложение. Возникает необходимость в более чётком разделении ролей между логикой и отображением данных.

Эту проблему решает **шаблонизация** — подход, при котором PHP-код, отвечающий за обработку данных, отделяется от HTML-кода, отвечающего за отображение интерфейса. Такой подход не только улучшает читаемость кода, но и упрощает его поддержку, повторное использование и масштабирование.

## Разделение логики и представления

В основе разработки любого веб-приложения лежит два основных процесса:

- **Логика приложения** — обработка данных, взаимодействие с базой, вычисления и принятие решений. Логика приложения отвечает на вопрос: "Что делать?".
- **Представление** — отвечает за то, как данные отображаются пользователю в виде HTML-разметки. Представление отвечает на вопрос: "Как это показать?"

**Пример**. _Прямой вывод HTML-кода в PHP_

Файл _index.php_:

```php
<?php

$title = "Мой сайт";
$userName = "Иван";
// Выводим HTML с использованием переменных
echo "<html><head><title>$title</title></head>";
echo "<body><h1>Добро пожаловать, $userName!</h1></body></html>";
```

Хотя такой подход выглядит простым, он создаёт прямую зависимость между логикой и представлением. Любые изменения в разметке требуют правки PHP-кода, а повторное использование блоков становится практически невозможным. Если сайт состоит из множества таких страниц, его сопровождение превращается в рутинную и уязвимую к ошибкам задачу.

Рекомендуемый подход – разделять эти две составляющие. **Принцип разделения ответственностей** (Separation of Concerns) [^2] говорит о том, что каждая часть кода должна выполнять свою задачу: логика в одном месте, а представление – в другом. Такой подход упрощает поиск ошибок, делает проект масштабируемым и понятным для других разработчиков.

Разделение логики и представления — первый шаг к шаблонизации, о которой подробнее пойдёт речь далее.

## Что такое шаблонизация и шаблонизаторы

После того, как мы поняли важность разделения логики и представления, переходим к **шаблонизации**.

**Шаблонизация** – метод организации кода, при котором HTML-шаблоны используются отдельно от PHP-скриптов.

**Шаблон** – это файл с HTML-разметкой, в котором предусмотрены «места-заготовки» для динамических данных. Эти заготовки могут быть простыми конструкциями для вывода переменных или минимальными управляющими конструкциями (например, условия или циклы). В шаблоне не должно быть сложной логики, ведь все данные подготавливаются заранее.

**Шаблонизаторы** – это инструменты, которые помогают автоматически подставлять данные в шаблоны [^1]. Они делают разработку быстрее и упрощают поддержку кода.

**Рендеринг** – процесс подстановки данных в шаблон и получения готового HTML-кода.

Итак, шаблонизация:

- упрощает разделение логики и представления,
- снижает дублирование кода,
- ускоряет разработку и делает проект более масштабируемым,
- улучшает читаемость и поддержку кода.

В этой главе мы поэтапно познакомимся с основами шаблонизации в PHP: от простых приёмов разделения кода до создания собственного шаблонизатора. Начнём с базового — прямого подключения файлов и вставки переменных — и постепенно перейдём к более продвинутым техникам, включая компонентный и объектно-ориентированный подходы.

## Типы шаблонов

Перед тем как перейти к конкретным способам шаблонизации, выделим основные типы шаблонов:

| Тип шаблона              | Назначение и содержимое                                                                                                                                                                                                                           |
| ------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Лейаут (`layout`)**    | Общий каркас HTML для страниц. Содержит повторяющиеся элементы: `<html><head>` с подключением стилей и скриптов, шапку сайта, подвал. Внутри лейаута оставляется «место» для уникального содержимого страницы, _например_, переменная `$content`. |
| **Страница (`page`)**    | Шаблон, уникальный для конкретной страницы. Включает только основной контент без общей обёртки. _Например_, на главной странице — список записей, на странице "О нас" — текст о компании. Может подключать мелкие блоки (компоненты) внутри себя. |
| **Блок (или компонент)** | Небольшой шаблон фрагмента страницы, который многократно используется в разных местах. _Например_, элемент списка (`<li>`) с содержимым записи блога, карточка товара, комментарий и т.п.                                                         |

Компоненты могут делиться на разные категории в зависимости от задачи, но в рамках курса мы будем рассматривать их как маленькие самостоятельные шаблоны, которые можно многократно использовать внутри страниц.

## Простые шаблоны с использованием require/include: разбиение страницы на части

В предыдущих главах было рассказано о важности разделения логики и представления. Одним из первых шагов в этом направлении может быть разбиение HTML-страницы на части: шапку, подвал, основное содержимое и подключение их на странице с помощью PHP-функций, которые были изучены ранее: `require`, `require_once`, `include`, `include_once`. Это улучшает структуру проекта и избавляет от дублирования кода.

Однако стоит понимать: **такой способ — это не полноценная шаблонизация**. Мы всё ещё смешиваем PHP и HTML, логика и представление не разделены окончательно. Тем не менее, такой подход полезен для новичков и хорошо подойдёт на ранних этапах разработки. Это своего рода "ручная шаблонизация" без использования специальных инструментов.

Рассмотрим пример. Допустим, у нас есть несколько страниц сайта, и все они должны иметь одинаковую **шапку** (header) и **подвал** (footer). Вместо того чтобы копировать один и тот же HTML-код на каждую страницу, мы выделим общий код в компоненты: `header.php` и `footer.php`. Затем на каждой странице будем подключать эти файлы с помощью `require_once`.

Для разделения страницы можно использовать следующую структуру файлов:

- `header.php` — содержит шапку сайта (_начало HTML-документа с общими элементами_).
- `footer.php` — содержит подвал сайта (_завершение HTML-документа_).
- `index.php` — основной скрипт страницы, который подключает шапку и подвал и выводит основной контент.

**Пример**. _Разделение страницы на части с использованием `require_once`_

Файл _header.php_:

```php
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title><?php echo $pageTitle; ?></title>
</head>
<body>
    <header>
        <h1>Мой замечательный сайт</h1>
        <nav>
            <a href="/">Главная</a> |
            <a href="/about.php">О нас</a>
        </nav>
    </header>
    <main>
```

Файл _footer.php_:

```php
    </main>
    <footer>
        &copy; <?php echo date('Y'); ?> Мой замечательный сайт
    </footer>
</body>
</html>
```

> [!NOTE]
> Обратите внимание: в `header.php` используется переменная `$pageTitle` для отображения названия страницы. Эта переменная должна быть определена до подключения файла `header.php`.

Файл _index.php_:

```php
<?php
    $pageTitle = "Главная страница";  // Определяем заголовок страницы
    $userName = "Иван";               // Динамический контент (имя пользователя)
    require_once 'header.php';        // Подключаем шапку (начало страницы)
?>
    <!-- Основной контент страницы -->
    <h2>Добро пожаловать!</h2>
    <p>Привет, <?php echo $userName; ?>! Рады видеть вас на нашем сайте.</p>
<?php
    require_once 'footer.php';        // Подключаем подвал (конец страницы)
```

Когда PHP интерпретирует файл `index.php`, он последовательно подставляет содержимое файла `header.php` на место вызова `require_once 'header.php'`, а содержимое файла `footer.php` — на место вызова `require_once 'footer.php'`. В результате для браузера формируется цельный HTML-документ, в котором в теге `<title>` отображается "Главная страница", а в тексте приветствия — имя пользователя [^3]​.

### Преимущества и недостатки подхода

Такой метод широко используется на первых этапах обучения и может быть вполне удобен для небольших проектов. Однако, как и любой подход, он имеет свои плюсы и минусы.

_Преимущества_:

1. **Простота и понятность**. Использование конструкций `require` и `include` не требует дополнительных библиотек и легко понимается даже начинающими разработчиками.
2. **Повторное использование кода**. Общие части сайта (_например_, header и footer), можно многократно использовать на разных страницах. Это уменьшает дублирование кода и ускоряет разработку.
3. **Удобная организация структуры проекта**. Вынос повторяющихся блоков в отдельные файлы помогает структурировать проект, делает его более читаемым и аккуратным.

_Недостатки_:

1. **Ограниченная функциональность**. Когда страниц и блоков становится много, управление подключениями становится запутанным, а код — менее гибким.
2. **Отсутствие логической изоляции**. Подключаемые файлы напрямую выполняются в том же пространстве имён, что и основной скрипт. Это может привести к неожиданным конфликтам между переменными, особенно если проект разрабатывает несколько человек.
3. **Смешивание логики и представления**. В одном и том же файле могут находиться и обработка данных, и HTML-разметка. Это затрудняет понимание кода, усложняет его поддержку и нарушает принцип разделения ответственностей.

Таким образом, данный метод — это хороший старт для организации кода, но не финальное решение. Этот метод даёт базовое понимание повторного использования и структуры проекта, но для более чистого и гибкого подхода стоит перейти к настоящей шаблонизации с передачей данных и минимальной логикой в шаблонах.

## Функции-компоненты

В прошлой главе было рассмотрен базовый способ разделения шаблонов на части с помощью `require` и `include`. Такой подход позволяет избежать дублирования кода и делает структуру проекта более организованной.

Однако бывают случаи, когда неудобно создавать отдельные файлы для каждого повторяющегося HTML-блока. _Например_, если один и тот же фрагмент — карточка товара, пост блога или кнопка — используется в нескольких местах страницы, то подключение отдельного шаблона каждый раз может быть неэффективным.

В таких ситуациях удобно использовать **функции-компоненты**.

### Что такое функция-компонент

**Функция-компонент** — это обычная PHP-функция, которая возвращает (или выводит) HTML-код, собранный на основе переданных данных. Она как бы «производит» готовый фрагмент интерфейса, используя шаблон, встроенный в функцию.

Это простой и быстрый способ создать переиспользуемые части интерфейса. Такой подход особенно полезен в небольших проектах или когда вам нужно быстро отобразить повторяющийся блок с разными данными.

### Пример использования функции-компонента

Предположим, на сайте часто встречается блок с карточкой поста: заголовок, краткое описание и кнопка "Читать далее". Вместо того чтобы каждый раз писать один и тот же HTML, можно создать функцию-компонент:

**Пример**. _Функция-компонент для карточки поста_

```php
function renderPostCard($post) {
    // Экранируем данные для безопасности
    $title   = htmlspecialchars($post["title"]);
    $excerpt = htmlspecialchars($post["excerpt"]);
    $id      = $post["id"];

    // Формируем HTML карточки поста и возвращаем как строку
    return "
      <div class='post-card'>
        <h3>{$title}</h3>
        <p>{$excerpt}</p>
        <a href='/post/{$id}'>Читать далее</a>
      </div>
    ";
}
```

Эта функция получает массив (или объект) `$post` с полями поста и собирает из них фрагмент разметки. При вызове `renderPostCard($post)` функция вернёт готовый HTML-код карточки поста, который можно вставить в любое место страницы.

**Пример**. _Использование функции-компонента_

```php
$posts = [
    ["id" => 1, "title" => "Новости компании", "excerpt" => "Свежие новости о нашей компании..."],
    ["id" => 2, "title" => "Советы по продукту", "excerpt" => "Как эффективно использовать наш продукт..."]
];

// Выводим карточки всех постов
foreach ($posts as $post) {
    echo renderPostCard($post);
}
```

Результат на странице:

```html
<div class="post-card">
  <h3>Новости компании</h3>
  <p>Свежие новости о нашей компании...</p>
  <a href="/post/1">Читать далее</a>
</div>
<div class="post-card">
  <h3>Советы по продукту</h3>
  <p>Как эффективно использовать наш продукт...</p>
  <a href="/post/2">Читать далее</a>
</div>
```

Это все еще не считается полноценной шаблонизацией:

- HTML и PHP всё ещё находятся в одном месте.
- Данные передаются прямо внутрь функции, где одновременно происходит и логика, и формирование представления.
- Это удобно и работает, но по-прежнему нарушает принцип разделения логики и представления.

Тем не менее, функции-компоненты — это следующий шаг к более чистому и модульному коду, особенно если проект пока не требует использования полноценного шаблонизатора.

### Преимущества и недостатки функции-компонента

_Преимущества_:

- **Простота и удобство**. Достаточно один раз описать компонент — и можно использовать его в любом месте с разными данными.
- **Локальность кода**. Всё, что относится к компоненту, находится в одной функции.
- **Гибкость**. Легко изменить структуру HTML — изменения сразу применятся везде.
- **Чистый код**. Код становится чище и компактнее, особенно в местах повторения.

_Недостатки_:

- **Не масштабируется**. При большом количестве компонентов и логики функция может разрастись и стать сложной для понимания.
- **Смешивание логики и представления**. Как и в примере с `require`, здесь нет чёткого разграничения между обработкой данных и их отображением.
- **Ограниченность**. По сравнению с настоящими шаблонизаторами здесь нет таких удобств, как наследование шаблонов, фильтры, встроенные условия и т.д.

## Шаблоны с метками (placeholders)

В предыдудущих главах были рассмотрены способы улучшения структуры HTML-кода с помощью подключения файлов (`header.php`, `footer.php`) и использования функций-компонентов. Эти подходы дают удобство и переиспользуемость, но они всё ещё не обеспечивают чёткого разделения логики и представления — PHP и HTML остаются тесно связаны.

Следующий шаг — использование шаблонов с метками, или placeholders. Этот подход в целом реализует идею шаблонизации: разделение логики и представления, упрощение поддержки и повторное использование кода, хотя и нет возможности использовать сложные конструкции.

### Что такое шаблон с метками?

**Шаблон с метками** — это обычный HTML-файл, внутри которого есть специальные метки (например, `{{username}}`), куда позже подставляются данные. Эти файлы могут иметь расширение `.tpl` или `.html`.

Главное преимущество в том, что в **шаблоне нет PHP-кода** — он остаётся только в PHP-скрипте, который "вставляет" значения в шаблон. Это означает, что дизайн и логика отделены: шаблон может верстать дизайнер, а код писать программист.

### Как это работает?

1. В шаблоне заранее проставляются метки, вроде {{имя_переменной}}.
2. PHP-скрипт загружает шаблон, ищет эти метки и заменяет их нужными значениями.
3. Результат выводится как обычный HTML.

### Пример использования меток

**Пример**. _Использование placeholders в шаблонах_

Файл _welcome.tpl_:

```html
<!-- welcome.tpl: HTML-шаблон с метками -->
<h1>Здравствуйте, {{username}}!</h1>
<p>Добро пожаловать на сайт <strong>{{site_name}}</strong>.</p>
```

В этом шаблоне `{{username}}` и `{{site_name}}` являются метками (_placeholders_), которые мы будем заменять на реальные данные.

> [!TIP]
> Метки можно обозначать разными способами. Мы выбрали двойные фигурные скобки для наглядности, но также можно использовать HTML-комментарии (`<!-- username -->`) или любые другие символы, чтобы избежать конфликтов с другим кодом.

Теперь создадим PHP-скрипт, который будет загружать шаблон, находить метки и заменять их на реальные значения:

**Пример**. _Замена placeholders на значения_

Файл _index.php_:

```php
<?php
// Определяем переменные для подстановки в шаблон
$userName = "Ivan";
$siteName = "my-blog.md";

// Загружаем шаблон из файла
$template = file_get_contents("welcome.tpl");
if ($templateContent === false) {
    die("Ошибка: не удалось открыть файл шаблона.");
}

// Заменяем метки на реальные данные
$html = str_replace(
    ["{{username}}", "{{site_name}}"],   // Массив меток
    [$userName,      $siteName],               // Массив значений
    $template
);

// Выводим результат
echo $html;
```

Что делает скрипт?

- **Чтение шаблона**: Функция `file_get_contents()` загружает содержимое файла `welcome.tpl` в строку `$templateContent`.
- **Замена меток**: С помощью `str_replace()` мы заменяем метки на реальные значения.
- **Вывод результата**: Полученный HTML-код с подставленными значениями выводится на экран.

Пользователю будет показан следующий HTML-код:

```html
<h1>Здравствуйте, Ivan!</h1>
<p>Добро пожаловать на сайт <strong>my-blog.md</strong>.</p>
```

### Функция для рендеринга шаблонов

Чтобы избежать дублирования кода и сделать процесс подстановки более универсальным, можно создать функцию, которая будет заменять метки на значения в любом шаблоне.

**Пример**. _Функция для замены placeholders_

```php
<?php

/**
 * Заменяет метки в шаблоне на значения из массива.
 *
 * @param string $templatePath Путь к файлу шаблона
 * @param array $placeholders Ассоциативный массив меток и значений
 *
 * @return string HTML-код с подставленными значениями
 */
function renderTemplate(string $templatePath, array $placeholders): string {
    $template = file_get_contents($templatePath);

    if ($template === false) {
        die("Ошибка: не удалось открыть файл шаблона.");
        return;
    }

    foreach ($data as $key => $value) {
        // Добавляем фигурные скобки к ключу
        $placeholder = '{{' . strtoupper($key) . '}}';
        // После чего заменяем ключи на значения
        $template = str_replace($placeholder, $value, $template);
    }

    return $template;
}

// Использование функции
$userName = "Ivan";
$siteName = "my-blog.md";

echo renderTemplate("welcome.tpl", [
    "username" => $userName,
    "site_name" => $siteName
]);
```

### Использование циклов 

Шаблоны можно использовать не только для вывода простых строк, но и для вставки сгенерированного HTML, например, списков:

**Пример**. _Шаблон с динамическим контентом_

Файл _list.tpl_. Шаблон списка элементов:

```html
<h2>Список продуктов</h2>
{{product_list}}
```

Файл _index.php_. Рендеринг шаблона с динамическим списком:

```php
<?php

// Создаём массив продуктов
$products = ["Товар 1", "Товар 2", "Товар 3"];

// Генерируем HTML-список
$productList = "<ul>";
foreach ($products as $product) {
    $productList .= "<li>$product</li>";
}
$productList .= "</ul>";

// Рендерим шаблон с подстановкой списка
echo renderTemplate("list.tpl", [
    "product_list" => $productList
]);
```

### Использования layout

Шаблоны можно использовать для layout-страниц, которые содержат общую структуру страницы. Это делает код более структурированным и легко поддерживаемым: внутренние страницы содержат только контент, а общие элементы хранятся в одном месте.

**Пример**. _Layout-шаблон_

Файл _layout.tpl_. Содержит общую структуру страницы:

```html
<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>{{page_title}}</title>
  </head>
  <body>
    <header>
      <h1>{{page_title}}</h1>
      <nav>
        <a href="/">Главная</a> |
        <a href="/about.php">О нас</a>
      </nav>
    </header>

    <main>{{content}}</main>

    <footer>&copy; {{page_title}}</footer>
  </body>
</html>
```

Файл _index.tpl_. Содержит контент главной страницы:

```html
<h2>Добро пожаловать!</h2>
<p>Привет, {{username}}! Рады видеть вас на нашем сайте.</p>
```

Файл _index.php_. Рендеринг страницы с использованием layout:

```php
<?php

// Определяем переменные
$userName = "Ivan";
$pageTitle = "my-blog.md";

$content = renderTemplate("index.tpl", [
    "username" => $userName
]);

// Загружаем layout-шаблон
$layout = renderTemplate("layout.tpl", [
    "page_title" => $pageTitle,
    "content" => $content,
]);

echo $layout;
```

### Это полноценная шаблонизация?

Несмотря на то, что шаблоны с метками позволяют отделить логику от представления, это не является полноценной шаблонизацией. Важно понимать, что:

- Нет условий (`if`), циклов (`foreach`) или вложенных блоков.
- Мы вручную обрабатываем метки.
- Код замены — простой и негибкий.

### Преимущества и недостатки подхода

_Преимущества_:

- **Простой формат** — HTML без PHP, понятный даже дизайнеру.
- **Универсальность** — Шаблоны можно использовать и вне PHP, например, с другим языком.
- **Отделение логики от представления** — Логика работы остаётся в PHP, а шаблон отвечает только за отображение.

_Недостатки_:

- **Ограниченные возможности**. Подход подходит только для подстановки данных, но не поддерживает сложные конструкции (_например_, циклы или условия).
- Поддержка и масштабирование сложны без дополнительной логики.

Использование шаблонов с placeholders — удобный и простой способ отделения логики от представления. Такой подход подходит для небольших и средних проектов, где нет необходимости в сложной логике отображения.

_Примечание_: Объектно-ориентированный подход к данному типу шаблонизации можно посмотреть в разделе `_samples/08_templating/08_01_placeholders_template_engine`.

## Шаблоны на основе PHP-файлов

На предыдущих этапах мы познакомились с несколькими подходами к упрощению HTML-шаблонов. Каждый из этих способов позволяет сделать код чуть более структурированным и избавляет от повторений.

Однако у всех рассмотренных подходов есть важное ограничение: в шаблонах нельзя использовать полноценные конструкции языка PHP — такие как условия (`if`), циклы (`foreach`) или вложенные компоненты. Чтобы преодолеть это ограничение и при этом сохранить разделение логики и представления, можно сделать следующий шаг — использовать обычные PHP-файлы в качестве шаблонов.

Чтобы расширить возможности шаблонизации, можно использовать в качестве шаблона обычные PHP-файлы. Такие файлы позволяют задействовать весь потенциал языка, включая циклы, условные конструкции и любые другие возможности PHP.

Это уже довольно близко к полноценной шаблонизации. Такой подход часто применяется в небольших фреймворках и библиотеках, где требуется простой и гибкий способ создания шаблонов.

### Идея шаблонов на основе PHP

Данный подход предполагает создание обычных `.php`-файлы, в которых размещается HTML-разметка и минимальный PHP-код (_например_, условия, циклы, переменные). Главная идея — подготовить данные в одном месте (в логике), а затем передать их в шаблон, не смешивая всё в одном файле.

Для реализации такого подхода можно создать функцию, которая будет выполнять роль шаблонизатора (далее будем называть её _"функция-шаблонизатор"_ или просто "_функция"_).

Функция-шаблонизатор выполняет следующие шаги:

- Проверяет существование шаблона.
- Извлекает переменные из массива (чтобы использовать их как `$title`, `$posts` и т.д.).
- Включает буферизацию вывода (чтобы вернуть результат как строку, а не сразу отправлять его).
- Подключает файл с шаблоном и записывает его содержимое в буфер.
- Возвращает результат как HTML-строку.

#### Почему буферизация и как это работает?

Буферизация позволяет накапливать весь вывод (`echo`, `include`, `require`) в памяти, а не сразу отправлять его в браузер. Это даёт нам контроль над результатом: мы можем сначала собрать HTML, а потом обработать или вернуть.

Для управления буфером в PHP используются функции:

- `ob_start()` — начать буферизацию.
- `ob_get_clean()` — получить содержимое буфера и очистить его.
- `ob_end_clean()` — просто очистить буфер без получения данных.

Проще говоря, с помощью `ob_start()` мы говорим PHP: "_Начни копить вывод во временном буфере_". Потом, с помощью `ob_get_clean()`, "забираем" всё накопленное и очищаем буфер.

**Пример**. _Буферизация вывода_

Рассмотрим пример:

```php
<?php

ob_start();
echo "Hello, ";
echo "world!";
$output = ob_get_clean();
```

В этом случае строки **"Hello, "** и **"world!"** будут сохранены в переменной `$output`, а не выведены на экран напрямую.

### Реализация функции шаблонизатора

```php
<?php

function renderTemplate(string $templatePath, array $vars = []): string {
    // Проверяем, существует ли файл шаблона
    if (!file_exists($templatePath)) {
        return "";  // Если файла нет, возвращаем пустую строку
    }

    // Извлекаем переменные из массива $vars
    extract($vars);  // Превращаем ключи массива в переменные

    // Включаем буферизацию вывода
    ob_start();
    // Подключаем шаблон
    require_once $templatePath;
    // Получаем содержимое буфера и очищаем его
    return ob_get_clean();
}
```

Что делает эта функция:

- Функция `extract($vars)` — превращает элементы ассоциативного массива в переменные. Например, массив ["title" => "Hello", "name" => "John"] после вызова extract($vars) создаст переменные `$title`и`$name`.
- `ob_start()` — включает буферизацию вывода, чтобы весь вывод (например, через `echo`) временно сохранялся в буфере, а не отправлялся сразу клиенту.
- `require_once $templatePath` — подключает шаблонный файл. Вместо немедленного вывода содержимое накапливается в буфере благодаря включённой буферизации.
- `ob_get_clean()` — извлекает накопленный HTML-код из буфера и очищает его. Это позволяет получить готовую строку с HTML и отключить буферизацию.

### Сбор страницы из компонентов с помощью функции-шаблонизатора

Рассмотрим пример использования функции-шаблонизатора для сборки страницы из компонентов. Рассмотрим веб-приложение с блогом, где на главной странице выводятся все посты.

Разделим представление на несколько компонентов:

- `layout.php` — лейаут (общий каркас страницы) с шапкой, подвалом и местом для контента.
- `posts.php` — шаблон главной страницы со списком всех записей.
- `post_item.php` — шаблон карточки одной записи.
- `index.php` — основной сценарий, который собирает итоговую страницу, вызывая функцию шаблонизации.

**Пример**. _Шаблоны для блога_

Файл _post_item.php_. Компонент: карточка одного поста.

```php
<article class="post-item">
  <h3 class="post-title">
    <a href="/posts.php?id=<?= $post['id']; ?>"><?= htmlspecialchars($post['title']); ?></a>
  </h3>
  <p class="post-excerpt"><?= htmlspecialchars($post['excerpt']); ?></p>
</article>
```

Файл _posts.php_. Компонент: список постов. Мы предполагаем, что переменная `$posts` — это массив записей, передаваемый в шаблон.

```php
<h2>Последние записи</h2>
<div class="posts-list">
  <?php foreach ($posts as $post): ?>
    <?= renderTemplate('post_item.php', ['post' => $post]); ?>
  <?php endforeach; ?>
</div>
```

В этом шаблоне мы проходимся по массиву записей и вызываем функцию `renderTemplate() `для каждого поста. Таким образом, каждая запись рендерится с помощью отдельного шаблона `post_item.php`.

Файл _layout.php_. Отвечает за общий каркас страницы: шапка, подвал и место для контента.

```php
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title><?= $pageTitle; ?></title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header class="main-header">
    <h1>Мой блог</h1>
    <nav>
      <a href="/">Главная</a> |
      <a href="/about.php">О нас</a>
    </nav>
  </header>
  <div class="container">
    <!-- Уникальный контент страницы: -->
    <?= $content; ?>
  </div>
  <footer class="main-footer">
    <p>© 2025 Мой блог. Все права защищены.</p>
  </footer>
</body>
</html>
```

> [!NOTE]
> Мы используем короткий синтаксис вывода `<?= ... ?>`, который эквивалентен `<?php echo ... ?>`. Он позволяет сделать код компактнее и удобнее для чтения.

Файл _index.php_. Основной сценарий, который собирает страницу из компонентов.

```php
<?php

// Пример данных (обычно они берутся из базы данных)
$posts = [
    ["id" => 1, "title" => "Первая запись", "excerpt" => "Краткое описание первой записи..."],
    ["id" => 2, "title" => "Вторая запись", "excerpt" => "Краткое описание второй записи..."]
];

// Рендерим контент главной страницы через шаблон posts.php
$content = renderTemplate('posts.php', ['posts' => $posts]);

// Рендерим полный layout, передавая заголовок и контент
$html = renderTemplate('layout.php', [
    'pageTitle' => 'Главная - Мой блог',
    'content'   => $content
]);

// Выводим готовую страницу
echo $html;
```

В данном коде:

- **Подготовка данных**. В массиве `$posts` хранятся записи блога с полями `id`, `title` и `excerpt`.
- **Рендеринг контента**. Вызывается функция `renderTemplate()` с шаблоном `posts.php` и массивом записей.
- **Рендеринг лейаута**. Готовый контент передаётся в основной шаблон layout.php, где он выводится в центре страницы.
- **Отображение**. Собранная HTML-страница выводится на экран.

### Упрощение рендеринга страницы

Чтобы не дублировать логику подключения layout, можно создать удобную функцию `renderPage()`, которая будет автоматически подключать layout и передавать в него контент.

```php
<?php

function renderPage(string $page, array $vars = [], string $layout = 'layout.php'): string {
    // Рендерим контент страницы
    $content = renderTemplate($page, $vars);

    // Рендерим layout, передавая заголовок и контент
    return renderTemplate($layout, [
        'pageTitle' => $vars['pageTitle'] ?? '';
        'content'   => $content
    ]);
}

// Теперь вывод полной страницы — это один вызов:
echo renderPage('posts.php', ['posts' => $posts, 'pageTitle' => 'Главная - Мой блог']);
```

### Альтернативный синтаксис PHP в шаблонах

При использовании PHP-кода внутри HTML (как в наших шаблонах) рекомендуется использовать альтернативный синтаксис для улучшения читаемости и уменьшения количества скобок `{}`.

Это улучшает читаемость HTML-шаблона, убирая лишние символы и делая структуру более явной.

### Преимущества и недостатки данного подхода

_Преимущества_:

1. **Гибкость и модульность** — можно собирать страницу из компонентов.
2. **Удобство работы с шаблонами** — Позволяет передавать данные в шаблоны через ассоциативные массивы, что делает код более понятным и структурированным.
3. **Централизация логики рендеринга** — Вся логика обработки шаблонов сосредоточена в одной функции, что упрощает поддержку и модификацию кода.
4. **Полноценный PHP в шаблонах** — Шаблоны поддерживают все конструкции языка PHP — условия (`if`), циклы (`foreach`), вызовы функций и другие элементы. Это делает шаблоны гибкими и выразительными. Однако важно не злоупотреблять этой возможностью: шаблоны должны оставаться максимально простыми и _использоваться исключительно для отображения данных, а не для выполнения бизнес-логики_.

_Недостатки_:

1. **Снижение производительности при больших объёмах данных**. Буферизация вывода при большом количестве шаблонов и данных может увеличить использование оперативной памяти и замедлить генерацию страниц.
2. **Отсутствие кэширования**. Каждый шаблон обрабатывается при каждом запросе заново. Без дополнительного кэширования это может повлиять на производительность при высокой нагрузке.
3. **Смешивание логики и представления**. Несмотря на вынесение логики, в шаблонах всё ещё остаются вызовы PHP и обработка переменных. Это может усложнить поддержку, особенно в больших проектах, и нарушает принцип строгого разделения ответственности.

_Примечание_: Объектно-ориентированный подход к данному типу шаблонизации можно посмотреть в разделе `_samples/08_templating/08_02_php_template_engine`.

## Безопасность при выводе данных в шаблонах

Одной из самых распространённых уязвимостей при формировании HTML-кода является *XSS* (Cross-Site Scripting) [^4]. Эта уязвимость возникает, когда злоумышленник вводит в приложение вредоносные данные, содержащие, *например*, теги `<script>`. Если такие данные попадают на страницу без должного экранирования, они выполняются в браузере пользователя, что может привести к утечке данных или другим атакам.

Чтобы избежать подобных уязвимостей, необходимо тщательно экранировать все данные, которые выводятся в шаблонах и могут содержать пользовательский ввод — *например*, данные из формы, URL или базы данных.

Для экранирования специальных символов HTML в PHP используются функции `htmlspecialchars()` и `htmlentities()`. Эти функции преобразуют потенциально опасные символы (такие как `<`, `>`, `&`, `"` и `'`) в безопасные HTML-сущности, предотвращая выполнение вредоносного кода.

Применяя экранирование на этапе вывода данных, вы значительно снижаете риск XSS-атак и делаете своё приложение безопаснее.

## Существующие шаблонизаторы в PHP

В главе были рассмотрены несколько способов ручной шаблонизации: от подключения компонентов с помощью `require` до рендеринга PHP-файлов и работы с placeholders. Эти подходы подходят для создания веб-приложений, но могут быть неудобными при работе с большими объёмами данных или сложными шаблонами.

В PHP существует множество популярных шаблонизаторов, которые упрощают процесс создания динамических страниц. В данной главе будут рассмотрены два шаблонизатора: _Twig_ и _Smarty_.

### Twig [^5]

**Twig** — это современный шаблонизатор для PHP, разработанный компанией `SensioLabs`. Он предоставляет мощные инструменты для работы с шаблонами, включая условия, циклы, наследование шаблонов и многое другое. Twig позволяет создавать безопасные и производительные шаблоны, особенно при работе с большими объемами данных.

#### Основные возможности Twig

- **Наследование шаблонов**. Возможность создавать базовые шаблоны и переопределять их в дочерних.
- **Условия и циклы**. Поддержка конструкций if, for, while и других.
- **Фильтрация и преобразование данных**. Использование встроенных и пользовательских фильтров.
- **Безопасность**. Автоматическое экранирование выходных данных для предотвращения XSS-атак.
- **Кэширование**. Возможность кэширования с целью повышения производительности.

#### Пример использования Twig

```php
$loader = new \Twig\Loader\FilesystemLoader('templates');
$twig = new \Twig\Environment($loader, [
    'cache' => 'cache',
]);

echo $twig->render('index.twig.html', [
  'name' => 'John Doe',
  'posts' => [
    ['title' => 'First post', 'content' => 'Content of the first post'],
    ['title' => 'Second post', 'content' => 'Content of the second post'],
  ],
]);
```

Файл _layout.twig.html_:

```html
<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>{% block title %}my-blog{% endblock %}</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <header class="main-header">
      <h1>Мой блог</h1>
      <nav>
        <a href="/">Главная</a> |
        <a href="/about.php">О нас</a>
      </nav>
    </header>
    <div class="container">{% block content %}{% endblock %}</div>
    <footer class="main-footer">
      <p>© 2025 Мой блог. Все права защищены.</p>
    </footer>
  </body>
</html>
```

Файл _index.twig.html_:

```html
{% extends 'layout.twig.html' %}

{% block title %}Главная - Мой блог{% endblock %} 

{% block content %}
<h2>Последние записи</h2>
<div class="posts-list">
  {% for post in posts %} 
    {% include 'post_item.twig.html' with {'post': post} %}
  {% endfor %}
</div>
{% endblock %}
```

### Smarty [^6]

**Smarty** — один из старейших и наиболее популярных шаблонизаторов в мире PHP. Он предлагает богатый набор функций и гибкость при создании шаблонов.

#### Основные возможности Smarty

- **Поддержка условий и циклов**. Позволяет легко управлять отображением данных.
- **Кэширование**. Повышает производительность за счет хранения готовых шаблонов.
- **Фильтры и модификаторы**. Возможность обработки данных перед выводом.
- **Наследование шаблонов**. Создание и использование базовых шаблонов.

#### Пример использования Smarty

```php
<?php

require_once '/path/to/smarty/libs/Smarty.class.php';

// Создание и конфигурация объекта Smarty
$smarty = new Smarty();
$smarty->setTemplateDir('/some/template/dir');
$smarty->setConfigDir('/some/config/dir');
$smarty->setCompileDir('/some/compile/dir');
$smarty->setCacheDir('/some/cache/dir');


// Передача данных в шаблон и рендеринг
$smarty->assign('name', 'John Doe');
$smarty->assign('posts', [
    ['title' => 'First post', 'content' => 'Content of the first post'],
    ['title' => 'Second post', 'content' => 'Content of the second post'],
]);
$smarty->display('index.tpl');
```

Файл _layout.tpl_:

```html
<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>{block name=title}my-blog{/block}</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <header class="main-header">
      <h1>Мой блог</h1>
      <nav>
        <a href="/">Главная</a> |
        <a href="/about.php">О нас</a>
      </nav>
    </header>
    <div class="container">{block name="content"}{/block}</div>
    <footer class="main-footer">
      <p>© 2025 Мой блог. Все права защищены.</p>
    </footer>
  </body>
</html>
```

Файл _index.tpl_:

```html
{extends file='layout.tpl'}

{block name=title}Главная - Мой блог{/block}

{block name=content}
<h2>Последние записи</h2>
<div class="posts-list">
  {foreach $posts as $post}
    {include file='post_item.tpl' post=$post}
  {/foreach}
</div>
{/block}
```

[^1]: _Шаблонизация в PHP_. maxsite.org [online resource]. Available at: https://maxsite.org/2024/templating-in-php
[^2]: _Separation of Concerns in Software Design_. nalexn.github.io [online resource]. Available at: https://nalexn.github.io/separation-of-concerns/
[^3]: _Шаблонизация в PHP_. htmlacademy.ru [online resource]. Available at: https://htmlacademy.ru/blog/php/templates
[^4]: _Cross-site scripting (XSS)_. mdn [online resource]. Available at: https://developer.mozilla.org/en-US/docs/Web/Security/Attacks/XSS
[^5]: _Twig_. twig.symfony.com [online resource]. Available at: https://twig.symfony.com/
[^6]: _Smarty_. smarty.net [online resource]. Available at: https://www.smarty.net/
