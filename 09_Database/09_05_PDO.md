# Работа с классом PDO (PHP Data Objects)

Расширение MySQLi хорошо подходит для работы именно с MySQL, но в PHP существует более универсальный интерфейс – **PDO** (PHP Data Objects) [^1], который в настоящее время является стандартом для работы с базами данных.

PDO предоставляет единый набор классов и методов для работы с разными СУБД (`MySQL`, `PostgreSQL`, `SQLite`, `SQL Server` и др.), используя драйверы. В этой секции мы рассмотрим, почему PDO часто предпочтительнее, и как им пользоваться.

## Преимущества PDO

Основные причины использовать PDO вместо MySQLi:

1. **Поддержка разных СУБД**. PDO поддерживает множество СУБД (MySQL, PostgreSQL, SQLite, SQL Server и др.). Для перехода на другую базу данных достаточно изменить строку подключения (DSN), а остальной код, как правило, остаётся без изменений. Это особенно важно при разработке кросс-СУБД-приложений или в случаях, когда возможна миграция на другую СУБД.
2. **Поддержка подготовленных запросов изначально**. В PDO подготовленные запросы реализованы как базовая концепция и используются через методы `prepare()` [^2] и `execute()` [^4]. Это упрощает защиту от SQL-инъекций и позволяет повторно выполнять один и тот же запрос с разными данными.
3. **Обработка ошибок через исключения**. PDO позволяет настраивать режим обработки ошибок. В режиме `PDO::ERRMODE_EXCEPTION` все ошибки выбрасываются как исключения, что упрощает отладку и даёт возможность использовать `try...catch` для централизованной обработки ошибок. В MySQLi для этого требуется вручную проверять коды ошибок.
4. **Объектно-ориентированный интерфейс**. PDO предлагает чисто объектно-ориентированный интерфейс. Классы `PDO` и `PDOStatement` предоставляют расширенные возможности, хорошо вписываясь в современные ООП-приложения на PHP.

> [!NOTE]
> Хотя MySQLi также поддерживает подготовленные выражения и может использоваться в объектно-ориентированном стиле (через класс `mysqli`), он ограничен исключительно MySQL. Функциональность MySQLi и PDO частично пересекается, но PDO считается более универсальным решением и часто используется в новых проектах благодаря своей гибкости и кросс-СУБД-поддержке.

## Подключение к базе данных

Для начала работы с PDO необходимо создать объект класса PDO, передав в его конструктор параметры подключения. Основным элементом является **DSN** (Data Source Name) — специальная строка, описывающая способ подключения к базе данных.

### Что такое DSN?

**DSN (имя источника данных)** — это строка, содержащая информацию о драйвере, адресе сервера, имени базы данных и дополнительных параметрах (_например_, кодировке).

Для подключения к MySQL DSN выглядит следующим образом:

```
mysql:host=HOSTNAME;dbname=DBNAME;charset=UTF8
```

Если представить, что DSN существует в реальном мире, его можно сравнить с адресом, по которому можно найти конкретного человека. Такой адрес содержит всю необходимую информацию для установления связи. _Например_: `city=London;street=OxfordStreet;number=10` — это аналог DSN, указывающего на точное местоположение в Лондоне.

### Пример подключения к базе данных через PDO

```php
<?php

$dsn = "mysql:host=localhost;dbname=my_database;charset=utf8";
$dbUser = "root";
$dbPass = "";

try {
    // Создаём PDO-объект (открываем соединение)
    $pdo = new PDO($dsn, $dbUser, $dbPass);
    // Устанавливаем режим обработки ошибок на выброс исключений
    $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    echo "Соединение с БД установлено через PDO.";
} catch (PDOException $e) {
    // Если подключиться не удалось, попадём сюда
    die("Ошибка подключения PDO: " . $e->getMessage());
}
```

В данном примере:

- Строка DSN включает в себя:
  - драйвер (`mysql`),
  - хост (`localhost`),
  - имя базы данных (`my_database`),
  - кодировку (`charset=utf8`), которая устанавливается сразу при подключении.
- Имя пользователя и пароль передаются отдельно — это упрощает смену данных авторизации без изменения DSN.
- Используется конструкция `try...catch`, поскольку при ошибке подключения (_например_, если сервер недоступен или пароль указан неверно) PDO выбрасывает исключение `PDOException` [^9].
- С помощью метода `setAttribute()` устанавливается режим обработки ошибок `PDO::ERRMODE_EXCEPTION`, который позволяет отлавливать ошибки через исключения. Это упрощает отладку и делает поведение более предсказуемым.

## Выполнение запросов и подготовленные выражения

Работа с базой данных через PDO обычно строится по следующей схеме: подготовка запроса → выполнение → получение результата (если запрос возвращает данные, например `SELECT`).

Рассмотрим несколько типичных случаев.

### Пример 1: Выполнение простого запроса без параметров.

Если запрос не содержит пользовательских данных, можно воспользоваться методом `query()` [^3]. Он выполняет SQL напрямую и возвращает объект PDOStatement.

**Пример**. _Получение всех пользователей из таблицы `users`_

```php
<?php

$sql = "SELECT id, name, email FROM users";
$stmt = $pdo->query($sql);  // Выполнение запроса

$users = $stmt->fetchAll(PDO::FETCH_ASSOC);  // Получение всех строк как ассоциативных массивов

foreach ($users as $user) {
    echo $user['name'] . " (" . $user['email'] . ")<br>";
}
```

В данном примере:

- Метод `query()` используется для простых SQL-запросов, не требующих привязки параметров.
- Возвращаемое значение — объект класса `PDOStatement`, содержащий результат выполнения запроса.
- Метод `fetchAll(PDO::FETCH_ASSOC)` извлекает все строки и возвращает их в виде массива ассоциативных массивов.
- Константа `PDO::FETCH_ASSOC` означает, что каждая строка результата будет представлена как массив с ключами по названиям столбцов. Доступны и другие режимы выборки:
  - `PDO::FETCH_NUM` — возвращает массив с индексами (0, 1, 2 и т.д.).
  - `PDO::FETCH_BOTH` — возвращает массив с индексами и ассоциативными ключами (по умолчанию).
  - `PDO::FETCH_OBJ` — возвращает каждую строку как объект (`StdClass`), доступ к данным осуществляется через `$row->field_name`.

### Пример 2: Подготовленный запрос с параметрами

Предположим, необходимо выбрать пользователя по его `email`, переданному, например, через GET-параметр (`$_GET['email']`). Это типичная ситуация, в которой важно защититься от SQL-инъекций. Для этого используются подготовленные запросы (Prepared Statements).

**Пример**. _получение пользователя по email (с позиционным плейсхолдером)_

```php
<?php

$email = $_GET['email'];  // Получение email из запроса

$stmt = $pdo->prepare("SELECT id, name, email FROM users WHERE email = ?");
$stmt->execute([$email]);

$user = $stmt->fetch(PDO::FETCH_ASSOC);

if ($user) {
    echo "Найден пользователь: " . $user['name'];
} else {
    echo "Пользователь с таким email не найден.";
}
```

В данном примере:

- Метод `prepare()` подготавливает SQL-запрос с плейсхолдерами (`?`) вместо конкретных значений.
- Метод `execute()` выполняет подготовленный запрос и подставляет значения из массива в соответствующие позиции. При этом значения автоматически экранируются — это обеспечивает защиту от SQL-инъекций.
- Метод `fetch(PDO::FETCH_ASSOC)` извлекает одну строку результата как ассоциативный массив.
- Если пользователь не найден, метод `fetch()` вернёт `false`.

Подготовленные запросы могут использовать именованные плейсхолдеры, начинающиеся с `:`. Это делает код более читаемым, особенно при большом количестве параметров:

```php
$stmt = $pdo->prepare("SELECT id, name, email FROM users WHERE email = :email");
$stmt->execute([':email' => $email]);
$user = $stmt->fetch(PDO::FETCH_ASSOC);
```

В данном примере:

- В массиве, переданном в `execute()`, ключи соответствуют именованным параметрам из запроса.
- Такой подход удобен, так как значения можно передавать в любом порядке.

Важно понимать, что метод `prepare()` не выполняет SQL-запрос сразу. Он лишь компилирует и подготавливает его к выполнению. Фактический запуск происходит при вызове `execute()`.

> [!NOTE]
> Использование подготовленных выражений — рекомендуемый способ взаимодействия с базой данных, особенно при работе с пользовательским вводом. Это снижает риск SQL-инъекций и упрощает повторное выполнение одних и тех же запросов с разными параметрами.

#### fetch() и fetchAll()

В зависимости от количества ожидаемых строк в результате запроса, для извлечения данных можно использовать методы `fetch()` [^6] или `fetchAll()` [^5]:

- `fetch()` — возвращает одну строку результата и перемещает указатель на следующую строку (_аналогично `mysqli_fetch_assoc()`_).
- `fetchAll()` — возвращает все строки в виде массива.

**Пример**. _Получение всех пользователей с помощью `fetchAll()`_

```php
<?php

$sql = "SELECT id, name, email FROM users";

$stmt = $pdo->query($sql);  // Выполнение запроса

$users = $stmt->fetchAll(PDO::FETCH_ASSOC);  // Получение всех строк как массива ассоциативных массивов

foreach ($users as $user) {
    echo $user['name'] . " (" . $user['email'] . ")<br>";
}
```

**Пример**. _Получение одной строки с помощью `fetch()`_

```php
<?php

$sql = "SELECT id, name, email FROM users";

$stmt = $pdo->query($sql);  // Выполнение запроса

$firstUser = $stmt->fetch(PDO::FETCH_ASSOC);  // Получение первой строки как ассоциативного массива

if ($firstUser) {
    echo "Первый пользователь: " . $firstUser['name'] . " (" . $firstUser['email'] . ")";
} else {
    echo "Пользователи не найдены.";
}

$secondUser = $stmt->fetch(PDO::FETCH_ASSOC);  // Получение второй строки как ассоциативного массива

if ($secondUser) {
    echo "Второй пользователь: " . $secondUser['name'] . " (" . $secondUser['email'] . ")";
} else {
    echo "Второй пользователь не найден.";
}

// Закрытие курсора, чтобы освободить ресурсы
// Это полезно, если вы хотите повторно использовать тот же запрос
$pdo->closeCursor();
```

> [!TIP]
> Если необходимо получить всего одну строку (например, конкретного пользователя по ID или email), предпочтительнее использовать `fetch()`. Если нужно обработать все строки результата, лучше применять `fetchAll()` — это удобно, но может потреблять больше памяти при большом объёме данных.

Если в таблице содержится большое количество записей, рекомендуется использовать метод `fetch()` в цикле. Это позволяет извлекать данные построчно. Такой подход особенно полезен при работе с крупными наборами данных, где использование `fetchAll()` может привести к переполнению памяти или снижению производительности.

**Пример**. _Получение всех пользователей с помощью `fetch()` в цикле_

```php
<?php

<?php

$sql = "SELECT id, name, email FROM users";
$stmt = $pdo->query($sql);  // Выполнение запроса

while ($user = $stmt->fetch(PDO::FETCH_ASSOC)) {
    echo $user['name'] . " (" . $user['email'] . ")<br>";
}
```

> [!IMPORTANT]
> Такой способ позволяет обрабатывать миллионы строк без риска исчерпания памяти и рекомендуется при построении отчётов, экспорте данных или любых других операций, связанных с большим объёмом информации.

### Пример 3: Вставка данных с помощью подготовленных выражений

Добавление новых записей через PDO осуществляется с использованием подготовленных выражений, что обеспечивает безопасность и читаемость кода.

```php
<?php

$name = $_POST['name'];
$email = $_POST['email'];

$stmt = $pdo->prepare("INSERT INTO users (name, email) VALUES (:name, :email)");
$stmt->execute([':name' => $name, ':email' => $email]);

$newId = $pdo->lastInsertId();
echo "Добавлена запись с ID = $newId";
```

В данном примере:

- Метод `prepare()` подготавливает SQL-запрос с именованными плейсхолдерами `:name` и `:email`.
- Метод `execute()` выполняет запрос и автоматически подставляет значения, при этом защищая от SQL-инъекций.
- Метод `$pdo->lastInsertId()` [^8] возвращает ID последней вставленной записи — аналог `mysqli_insert_id()` в MySQLi. Это работает только при наличии автоинкрементного поля (например, `id`).

> [!TIP]
> Заметим, что по сравнению с процедурным стилем MySQLi, использование PDO делает код более компактным и читаемым, особенно при частой работе с подготовленными запросами и параметрами.

## Обработка ошибок PDO

Как уже упоминалось ранее, при подключении мы установили режим обработки ошибок `PDO::ERRMODE_EXCEPTION.` Это означает, что при возникновении любой ошибки — синтаксической, логической, нарушения ограничений (например, уникальности) и т. д. — будет выброшено исключение типа `PDOException`.

**Пример**. _Обработка ошибок при выполнении SQL-запроса_

```php
<?php

try {
    $pdo->query("SELECT * FROM nonexistent_table");
} catch (PDOException $e) {
    echo "SQL ошибка: " . $e->getMessage();
}
```

Если таблица `nonexistent_table` отсутствует, будет выброшено исключение, и управление передастся в блок `catch`. Там можно получить текст ошибки с помощью метода `getMessage()`.

### Альтернатива: режим без исключений

Если не включён режим `ERRMODE_EXCEPTION`, PDO работает в "тихом" режиме (`ERRMODE_SILENT`). В этом случае при ошибке необходимо вручную проверять результат и обращаться к методу `$pdo->errorInfo()`:

```php
$result = $pdo->query("SELECT * FROM nonexistent_table");

if (!$result) {
    $errorInfo = $pdo->errorInfo();
    echo "Код ошибки: " . $errorInfo[0] . " — " . $errorInfo[2];
}
```

> [!IMPORTANT]
> Напомним, что не нужно отображать пользователю технические детали ошибок базы данных. Такие сообщения могут содержать чувствительную информацию — имена таблиц, структурные детали и т.д. В рабочем (продакшн) режиме ошибки следует: логировать в файл или систему логирования и показывать пользователю безопасное сообщениеб например: _"Произошла ошибка. Пожалуйста, попробуйте позже_

## Закрытие соединения

При завершении работы с базой данных соединение автоматически закрывается, как только объект PDO уничтожается (обычно в конце выполнения скрипта). Однако при необходимости соединение можно закрыть явно, присвоив объекту `null`:

```php
<?php

$pdo = null;  // Явное закрытие соединения
```

Зачем закрывать соединение вручную?

- **Освобождение ресурсов**. Каждое активное соединение потребляет ресурсы сервера. При высоконагруженных системах или большом числе одновременных подключений важно освобождать ресурсы как можно раньше.
- **Контроль за временем жизни соединения**. В некоторых случаях (например, при пакетной обработке данных или работе с несколькими базами) важно вручную управлять моментом закрытия соединения.
- **Безопасность**. Явное закрытие соединения может предотвратить случайный повторный доступ к базе в нежелательный момент, особенно если объект PDO передаётся в другие части кода.

> [!NOTE]
> В обычных веб-приложениях, где каждый запрос обрабатывается отдельно, в большинстве случаев не требуется явно закрывать соединение — PHP сделает это автоматически по завершении скрипта. Однако в фоновом режиме, в CLI-скриптах, демонах и тестах ручное управление соединением становится полезным.

[^1]: _Модуль доступа к базам данных PHP Data Objects_. php.net [online resource]. Available at: https://www.php.net/manual/ru/book.pdo.php
[^2]: _PDO::prepare — Prepare a statement for execution and return a statement object_. php.net [online resource]. Available at: https://www.php.net/manual/ru/pdo.prepare.php
[^3]: _PDO::query — Execute an SQL statement and return the result set as a PDOStatement object_. php.net [online resource]. Available at: https://www.php.net/manual/ru/pdo.query.php
[^4]: _PDO::execute — Execute a prepared statement_. php.net [online resource]. Available at: https://www.php.net/manual/ru/pdo.statement.execute.php
[^5]: _PDOStatement::fetchAll — Fetches all of the remaining rows in a result set_. php.net [online resource]. Available at: https://www.php.net/manual/ru/pdostatement.fetchall.php
[^6]: _PDOStatement::fetch — Fetches the next row from a result set_. php.net [online resource]. Available at: https://www.php.net/manual/ru/pdostatement.fetch.php
[^7]: _PDOStatement::closeCursor — Closes the cursor, enabling the statement to be executed again_. php.net [online resource]. Available at: https://www.php.net/manual/ru/pdostatement.closecursor.php
[^8]: _PDO::lastInsertId — Returns the ID of the last inserted row or sequence value_. php.net [online resource]. Available at: https://www.php.net/manual/ru/pdo.lastinsertid.php
[^9]: _PDOException — Exception class for PDO errors_. php.net [online resource]. Available at: https://www.php.net/manual/ru/class.pdoexception.php