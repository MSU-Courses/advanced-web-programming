# SQL-инъекции: уязвимость и способы защиты

**SQL-инъекция** — одна из самых распространённых и опасных уязвимостей при работе с базами данных. Она возникает тогда, когда пользовательский ввод (данные, переданные через формы, URL и т. д.) вставляется напрямую в SQL-запрос без предварительной обработки и экранирования. В результате злоумышленник может изменить структуру запроса и получить несанкционированный доступ к данным или даже повредить базу [^1].

Само название «SQL-инъекция» легко объяснить. Вспомните, что такое инъекция в медицине — это введение в организм вещества, которого там изначально не было. Аналогично, при SQL-инъекции злоумышленник «вводит» в SQL-запрос вредоносный код, чтобы изменить его поведение и добиться несанкционированного доступа к данным.

## Пример SQL-инъекции

Рассмотрим типичный пример: пользователь вводит логин и пароль для авторизации, а код обрабатывает их следующим образом:

```php
<?php

$login = $_POST['login'];
$password = $_POST['password'];

$query = "SELECT * FROM users WHERE login = '$login' AND password = '$password'";
$result = mysqli_query($connection, $query);

if (mysqli_num_rows($result) > 0) {
    echo "Welcome!";
} else {
    echo "Invalid login or password.";
}
```

Если пользователь введёт в поле логина следующую строку:

```
admin' OR '1'='1
```

то SQL-запрос примет следующий вид:

```sql
-- OR '1'='1' - это всегда истинное выражение
-- Все выражение станет истинным
SELECT * FROM users WHERE login = 'admin' OR '1'='1' AND password = '$password'
```

Условие `1 = 1` всегда истинно, поэтому запрос вернёт первую найденную строку — например, данные администратора. Таким образом, злоумышленник может получить доступ к системе без пароля.

Атака может быть ещё опаснее. Если ввести в поле пароля следующее:

```
123'; DROP TABLE users; --
```

то сформированный запрос будет выглядеть так:

```sql
SELECT * FROM users WHERE login = '...' AND password = '123'; DROP TABLE users; --'
```

Здесь выполняются два запроса подряд:

- _первый_ — на авторизацию
- _второй_ — на удаление таблицы users.

Комментарий `--` отключает остаток строки. Это может привести к полной потере данных.

> [!TIP]
> В SQL символы `--` обозначают начало комментария. Всё, что идёт после них, игнорируется. Злоумышленники активно используют это для обрезки частей запроса.

## Как защититься?

### Использование подготовленных выражений

Самый надёжный способ — использование **подготовленных выражений** (prepared statements).

Подготовленные запросы отделяют SQL-логику от пользовательских данных. Значения подставляются в подготовленный шаблон отдельно, а СУБД сама заботится об экранировании и защите. Даже если пользователь попытается ввести вредоносный код, он будет воспринят как обычная строка, а не как часть SQL.

Для примера перепишем вставку с использованием подготовленного запроса `MySQLi`:

**Пример**. _Безопасная вставка данных в MySQL с помощью подготовленных выражений_

```php
<?php

$name  = $_POST['name'];
$email = $_POST['email'];

// Подготовка шаблона SQL-запроса с плейсхолдерами
$stmt = mysqli_prepare($conn, "INSERT INTO users (name, email) VALUES (?, ?)");

// Привязка параметров: "s" означает string (строка)
mysqli_stmt_bind_param($stmt, "ss", $name, $email);

// Выполнение запроса
mysqli_stmt_execute($stmt);

if (mysqli_stmt_errno($stmt) === 0) {
    $newId = mysqli_insert_id($conn);
    echo "Пользователь успешно добавлен. ID = $newId";
} else {
    echo "Ошибка при вставке: " . mysqli_stmt_error($stmt);
}

mysqli_stmt_close($stmt);
```

- Знаки `?` выступают как плейсхолдеры (места подстановки значений).
- Метод `bind_param()` привязывает переменные к этим плейсхолдерам. Строка `"ss"` означает, что оба параметра — строки.
- Все потенциально опасные символы будут экранированы автоматически.
- Подготовленный запрос компилируется один раз, после чего может быть безопасно выполнен с разными параметрами.

### Вариант с ручным экранированием (менее надёжный)

Если по каким-либо причинам невозможно использовать подготовленные выражения, можно применять экранирование данных вручную с помощью `mysqli_real_escape_string($conn, $value)`, которая добавляет слэши перед опасными символами (_например_, превращает `в`\'`). Однако этот способ требует высокой внимательности и не исключает человеческих ошибок.

```php
$name  = $_POST['name'];
$email = $_POST['email'];

// Экранируем данные
$name  = mysqli_real_escape_string($conn, $name);
$email = mysqli_real_escape_string($conn, $email);

// Выполняем запрос
$query = "INSERT INTO users (name, email) VALUES ('$name', '$email')";
$result = mysqli_query($conn, $query);
if ($result) {
    $newId = mysqli_insert_id($conn);
    echo "Добавлен новый пользователь с ID = $newId";
} else {
    echo "Ошибка при вставке: " . mysqli_error($conn);
}
```

> [!IMPORTANT]
> **Ручное экранирование — временное решение** и не защищает от всех возможных атак. Подготовленные выражения всегда предпочтительнее и должны использоваться по умолчанию.

[^1]: _SQL injection_. PortSwigger [online resource]. Available at: https://portswigger.net/web-security/sql-injection
[^2]: _Подготовленные запросы и хранимые процедуры_. php.net [online resource]. Available at: https://www.php.net/manual/ru/pdo.prepared-statements.php
